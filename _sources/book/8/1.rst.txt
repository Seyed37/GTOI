BST
============

درخت های دودویی، درخت های ریشه داری هستند که هر راس حداکثر ۲ بچه دارد. Binary Search Tree یا درخت جست و جوی دودویی، یک داده ساختار درختی است که روی هر راس آن یک عدد نوشته شده است. فرض کنید روی هر راس :math:`u` عدد :math:`a_u` نوشته شده باشد. BST دارای ویژگی های زیر است.

- تمام اعداد نوشته شده روی زیردرخت سمت چپ :math:`u` کمتر از :math:`a_u` هستند.
- تمام اعداد نوشته شده روی زیردرخت سمت راست :math:`u` بیشتر از :math:`a_u` هستند.

این ویژگی جالب BST باعث می شود که جست و جو به دنبال یک عدد خاص مثل :math:`x` در این داده ساختار برای ما آسان باشد. به این صورت که اگر در زیردرخت :math:`u` به دنبال عدد :math:`x` می گردیم ابتدا :math:`a_u, x` را مقایسه می کنیم.

- اگر :math:`a_u = x` که این مقدار را پیدا کرده ایم.
- اگر :math:`a_u > x` آنگاه باید در زیردرخت بچه سمت چپ :math:`u` به دنبال :math:`x` بگردیم.
- اگر :math:`a_u < x` آنگاه باید در زیردرخت بچه سمت راست :math:`u` به دنبال :math:`x` بگردیم.

پس در واقع طی عملیات جست و جو به دنبال :math:`x` یک مسیر از ریشه تا یک راس را طی می کنیم پس بیشترین تعداد عملیاتی که انجام می دهیم برابر با ارتفاع درخت است!

به صورت معمول BST ها این عملیات های پایه ای را انجام می دهند.

- یک راس جدید با مقدار :math:`x` به ساختار اضافه کن.
- راس :math:`u` (دلخواه) را حذف کن.
- راسی که مقدار :math:`x` روی آن نوشته شده را پیدا کن (یا بگو چنین راسی وجود ندارد).

همانطور که دیدیم BST ها عملیات سوم را با :math:`O(h)` انجام می دهند پس باید اضافه و حذف راس (عملیات اول و دوم) را طوری انجام دهیم که ارتفاع درخت زیاد نشود!

به عنوان مثال می توان برای اضافه کردن مقدار جدید :math:`x` (عملیات اول) به سادگی دنبال :math:`x` بگردیم. اگر :math:`x` را یافتیم که نیاز به اعمال تغییر در درخت نیست. در غیراینصورت می توانیم همانجایی که انتظار داشتیم :math:`x` باشد و نبود (اولین مرحله ای که جست و جو ما را به راسی خارج از درخت هدایت می کند)، راسی با مقدار :math:`x` قرار دهیم. این یک روش خیلی ساده برای انجام عملیات اول است اما اگر این روش را در پیش بگیریم ممکن است بعد از مدتی ارتفاع درخت خیلی زیاد شود که اصلا بهینه نیست. مثلا با اضافه کردن  اعداد 1 تا :math:`n` به صورت صعودی، در نهایت به یک مسیر :math:`n` راسی می رسیم.

برای حذف کردن مقدار :math:`x` یک روش ساده این است که ابتدا راس :math:`u` را پیدا کنیم که :math:`a_u = x` است. سپس راس با **کمترین مقدار** در زیر سمت **راست** :math:`u` پیدا کنیم (اگر زیردرخت سمت راست نداشت به سادگی می توان کل زیردرخت سمت چپ را به جای زیر درخت :math:`u` قرار داد). و این راس کمینه را به جای :math:`u` قرار دهیم. می توان بررسی کرد که در اینصورت درخت حاصل همچنان ویژگی BST را حفظ خواهد کرد. پیدا کردن راس با کمترین مقدار هم به این شکل ممکن است که هر زمان که می توانستیم به چپ برویم، به چپ می رویم هر زمان که نتوانستیم به چپ برویم به راس با مقدار کمینه رسیده ایم. (چرا؟)

الگوریتم های متفاوتی برای BST وجود دارد که از جمله معروف ترین آن ها می توان به AVL tree, Red–black tree, Tango tree, Treap اشاره کرد. که هر کدام به روش متفاوتی عمل می کنند اما تمام آن ها تلاش می کنند که ارتفاع درخت را :math:`O(log(n))` نگه دارند!

بعضی از آن ها مثل Treap به صورت احتمالاتی کار می کنند یعنی ممکن است ارتفاع درخت زیاد شود اما اگر میانگین ارتفاع در مراحل مختلف را در نظر بگیریم امیدریاضی آن از :math:`O(log(n))` خواهد بود.

در کل می توان فرض کرد که الگوریتم های مشهور BST (که در اینجا به بحث درباره آن نمی پردازیم) تمام عملیات ها را با پیچیدگی زمانی :math:`O(log(n))` انجام می دهند. جالب است بدانید std::set که در زبان c++ کاربرد فراوان دارد در واقع با Red–black tree پیاده سازی شده است.
