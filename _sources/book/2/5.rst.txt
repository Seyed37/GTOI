dfs
=========

الگوریتم dfs یکی از روش های پیمایش گراف است و یکی از ساده ترین و پایه ای ترین الگوریتم های گراف می باشد. این الگوریتم در عین سادگی ویژگی های جالبی دارد و برخلاف تصور در حل مسائل تئوری و عملی کاربرد فراوان دارد!

اولین مسئله
-------------

فرض کنید در یک هزارتو گیر کرده اید که به صورت یک گراف است. یعنی در هر راس گراف یک اتاق قرار دارد و هر یال نشان دهنده یک راهرو بین دو اتاق است. همچنین حافظه شما به قدری قوی است که می توانید اگر به یک اتاق تکراری رفتید تشخیص بدهید که این اتاق تکراری است و هنگامی که در یک اتاق هستید تنها می توانید راهرو های مجاور آن را ببینید. همچنین یک نخ به همراه دارید که یک سر آن به اتاقی که اول کار در آن قرار دارید بسته شده است و سر دیگر در دستان شماست. در یکی از راس های گراف گنجی قرار دارد. هدف شما این است که گنج را بیابید. چگونه این کار را انجام می دهید؟

پیدا کردن گنج به سادگی انجام الگوریتم زیر است. تا زمانی که به گنج نرسیدیم الگوریتم زیر را انجام دهید :

- اگر همه اتاق های مجاور تکراری بودند به اتاقی برو که برای اولین بار از آن به اتاق فعلی آمده ای. (کافی است نخی که دستمان است را دنبال کنیم). 
- در غیراینصورت به یکی از اتاق های مجاور که تکرای نیست برو.

چرا این الگوریتم مسئله ما را حل می کند؟ نکته اینجاست که زمانی که ما برای اولین بار در یک اتاق قرار می گیریم تمام تلاشمان را می کنیم که از آن اتاق مسیری به گنج پیدا کنیم. در نتیجه وقتی که همه اتاق های مجاور تکراری می شوند و ما نخ را دنبال کرده و بر می گردیم می توان نتیجه گرفت که هیچ مسیری از آن اتاق به گنج وجود ندارد. در نتیجه هیچ گاه دیگر نباید وارد این اتاق شویم. (و این منطق که نباید وارد اتاق تکراری شویم نیز از همینجا ناشی می شود).

می توان با یک دید متفاوت تر هم به مسئله نگاه کرد. به ازای هر یال :math:`uv` اگر یکی از :math:`u,v` را ببینیم قطعا دیگری را نیز خواهیم دید. (زیرا زمانی کارمان با یک راس تمام می شود که تمام مجاور های آن تکراری باشند). در نتیجه اگر یک راس از مولفه همبندی را ببینیم تمام راس های دیگر آن را نیز خواهیم دید.

مولفه های همبندی
------------------

گراف :math:`G` به شما ورودی داده شده است. شما باید تعداد مولفه های همبندی این گراف را بیابید.

آنچه در این قسمت بررسی می کنیم تصویری کلی از الگوریتم dfs است. فرض کنید آرایه mark نشان می دهد که چه راس هایی قبلا دیده شده اند و در ابتدای کار تمام خانه های آن false است. حالا الگوریتم ما به اینصورت خواهد بود :

.. code-block:: cpp

  void dfs(int v){
     mark[u] = true;
     for(int u : g[u]){
	 if(mark[u] == false)
             dfs(u);
     }
  }

از شهودی که با حل مسئله بالا به دست آوردیم استفاده کنید. وقتی dfs(v) صدا زده می شود الگوریتم تلاش می کند که به صورت بازگشتی تمام راس هایی که با :math:`v` می توان به آن رسید را ببیند سپس dfs(v) به اتمام می رسد و به راسی به نام :math:`par` بر می گردیم که از آن برای اولین بار به :math:`v` رسیده بودیم.

در نتیجه می توان دید که پس از اجرای این تابع تمام راس هایی که در مولفه همبندی راس شروع قرار دارند دیده می شوند. پس برای حل مسئله کافیست در هر مرحله راسی مثل :math:`u` را انتخاب کنیم که mark آن false باشد. سپس dfs(u) را اجرا کرده و به جواب مسئله یکی اضافه کنیم.


درخت dfs
-----------------

الگوریتم dfs علاوه بر اینکه گراف ما را پیمایش می کند این پیمایش را به صورت خاصی انجام می دهد! حالا با برخی از ویژگی های جالب این پیمایش آشنا می شویم.

فرض کنید یال های گراف در ابتدا آبی هستند. حالا هر گاه که برنامه در راس :math:`v` بود و با طی کردن یال :math:`uv` به راس جدید :math:`u` می رسید یال :math:`uv` را قرمز کنید.

در ابتدا توجه کنید که یال های قرمز تشکیل یک درخت می دهند! زیرا هر بار که یک یال قرمز می شود یک سر آن متصل یه راسی است که قبلا ندیده بودیم. پس مثل این است که یکی یکی به این درخت برگ اضافه می کنیم! به این درخت به دست آمده از الگوریتم dfs، درخت dfs می گوییم. ویژگی جالب dfs این است که وقتی اجرای dfs(u) شروع می شود راس :math:`u` در درخت قرمز ها تنها یک برگ است و زمانی که اجرای dfs(u) به پایان می رسد زیردرخت :math:`u` به طور کامل ساخته شده است. پس می توانید ببینید که 

پس می بینید که پس از اجرای الگوریتم dfs روی یک گراف همبند، یک درخت فراگیر از این گراف را به دست خواهیم آورد. این درخت فراگیر را از راس شروع ریشه دار کنید.

حالا به ویژگی جالبی که روی یال های آبی به دست می آید توجه کنید.

به یال :math:`uv` بک اج (back edge) می گوییم اگر یکی از :math:`u,v` جد دیگری باشد. در غیراینصورت به این یال کراس اج (cross edge) می گوییم.

ادعا می کنیم در درخت dfs تمام یال ها بک اج هستند!

.. figure:: /_static/back_edge.png
   :width: 50%
   :align: center
   :alt: اگه اینترنت یارو آشغال باشه این میاد


برای اثبات اینکه تمام یال ها بعد از پیمایش dfs کراس اج هستند یک یال :math:`uv` دلخواه را در نظر بگیرید. بدون کم شدن از کلیت مسئله فرض کنید در الگوریتم ابتدا به راس :math:`u` وارد شده ایم. در اینصورت موقع شروع dfs(u) راس math:`v` هنوز دیده نشده است. همچنین زمانی که dfs(u) به پایان می رسد راس :math:`v` باید دیده شده باشد (زیرا مجاور راس :math:`u` است). بنابراین اگر درخت dfs را در نظر بگیرید راس :math:`v` باید درون زیردرخت :math:`u` باشد! در نتیجه :math:`u` جد :math:`v` است پس یال :math:`uv` بک اج خواهد بود.

در آینده از این قضیه که بعد از اجرای dfs تمام یال ها بک اج هستند استفاده های بسیاری خواهیم کرد!

مسیر ماکسیمال و dfs
-------------------------


پیمایش درخت
--------------------

یکی از حالات خاص مسئله پیمایش گراف، پیمایش درخت ها است. در این قسمت می بینیم که پیمایش درخت ها می تواند با الگوریتم dfs به صورت ساده تر انجام شود.

not yet
