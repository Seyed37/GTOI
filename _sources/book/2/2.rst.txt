فاصله در درخت و گراف
==========================

دو راس :math:`u,v` در گراف را در نظر بگیرید. فاصله این دو راس طول (تعداد یال ها) کوتاه ترین مسیر بین این دو راس تعریف می شود. در درخت ها صحبت در مورد فاصله به مراتب راحت تر از گراف در حالت کلی است چرا که در درخت مسیر بین هر دو راس یکتا است.

قطر چیست؟

شعاع چیست؟

مرکز چیست؟

سنتروید چیست؟‌(در حالت کلی و در درخت)

خروج از مبدا چیست؟

بیشترین فاصله از هر راس یکی از دو سر قطر است.


مجموع فاصله ها
-----------------------

فرض کنید در مسئله ای هدف مینیمم یا ماکسیمم کردن مجموع فاصله بین هر دو راس است فرض کنید به این مجموع چگالی گراف بگوییم. به صورت شهودی هر چه چگالی گراف کمتر باشد گراف جمع و جور تر و هر چه چگالی گراف بیشتر باشد گراف پهن و پخش تر است.

در ضمن برای اینکه فاصله تعریف شده باشد فرض کنید موضوع بحث ما گراف های همبند می باشد.

کمینه کردن چگالی گراف
~~~~~~~~~~~~~~~~~~~~~~~~~~~

فاصله بین دو راس حداقل 1 است. و در گراف :math:`K_n` فاصله بین هر دو راس دقیقا 1 است. پس کمترین چگالی ممکن در گراف :math:`K_n` به دست می آید که برابر با :math:`n \choose 2` می باشد.

حالا اگر دامنه بحث را به درخت ها محدود کنیم مسئله کمی سخت تر می شود. اما همچنان می توان اینگونه استنتاج کرد.

- دقیقا :math:`n-1` جفت از راس ها هستند که فاصله اشان دقیقا 1 است. زیرا درخت :math:`n-1` یال دارد.
- هر جفتی از راس ها که به همدیگر یال ندارند دارای فاصله حداقل 2 هستند.

در نتیجه کمترین چگالی ممکن حداقل :math:`2 \times {n \choose 2} - (n-1)` می باشد و تنها مثالی که در حالت این کران صدق می کند حالتی است که فاصله بین هر دو راس **حداکثر** برابر با 2 است. تنها درختی که این ویژگی را دارد ستاره می باشد (همانطور که در عکس می بینید). زیرا که اگر در این گراف دو برگ باشند که پدر مشترک نداشته باشند در اینصورت فاصله آنها حداقل 3 خواهد بود.

 .. figure:: /_static/star.png
   :width: 50%
   :align: center
   :alt: اگه اینترنت یارو آشغال باشه این میاد

بیشینه کردن چگالی گراف
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

در این حالت توجه کنید که اگر یالی را حذف کنیم و حذف این یال گراف را ناهمبند نکند باید اینکار را بکنیم. زیرا که حذف یال باعث بیشتر شدن چگالی می شود (چرا؟). پس گرافی که چگالی آن بیشینه است را باید در میان درخت ها جست و جو کرد (زیرا همانطور که گفتیم همه یال های آن باید برشی باشد).

حالا یک راس خاص مثل :math:`u` را در نظر بگیرید. ادعا می کنیم جمع فواصل همه راس ها از :math:`u` حداکثر برابر با :math:`n \choose 2` است.

برای اثبات فرض کنید درخت را از :math:`u` آویزان کرده ایم و به ازای هر ارتفاع می دانیم که چند راس در این ارتفاع قرار دارند و بیشترین ارتفاع :math:`H` باشد. در اینصورت به ازای هر ارتفاعی از 0 تا :math:`H` حداقل یک راس از این ارتفاع باید داشته باشیم. حالا اگر حداقل دو راس در یک ارتفاع داشتیم می توان یکی از آن ها را به ارتفاع بالاتر برد و در اینصورت جمع ارتفاع ها بیشتر خواهد شد. با تکرار این فرایند به حالتی می رسیم که در هر ارتفاع 0 تا :math:`n-1` دقیقا یک راس باشد (یعنی درخت یک مسیر شده) که در این حالت جمع فاصله ها از :math:`u` برابر با :math:`1 + 2 + ... + (n-1) = {n \choose 2}` خواهد بود. پس ثابت کردیم که جمع فاصله ها از هر راس :math:`u` حداکثر :math:`n \choose 2` است.

پس حالا برای اینکه به یک کران برسیم در هر مرحله یک **برگ** را از درخت حذف کنید و جمع فاصله ها از این برگ را محاسبه کنید. جمع تمام مقادیر برابر با چگالی گراف خواهد بود که طبق آنچه گفتیم حداکثر :math:`\sum\limits_{i=1}^{n} {i \choose 2} = {{n+1} \choose 3}` خواهد بود (طبق اتحاد چوشی چی).

می توان نتیجه گرفت تنها گرافی که در حالت تساوی این کران صدق می کند گراف مسیر است.



درخت پشتیبانی
------------------------

فرض کنید یک شبکه ارتباطی داریم که :math:`n` شهر را به هم وصل می کنند. برای اطمینان یک شبکه ارتباطی پشتیبانی هم آماده کرده ایم که در صورت ایجاد اختلال در شبکه اصلی از شبکه پشتیبانی استفاده کنیم تا ارتباط قطع نشود.

به زبان گراف دو درخت :math:`n` راسی :math:`T` و :math:`T ^ {\prime}` داریم. می خواهیم ثابت کنیم در صورتیکه یکی از یال های :math:`T` مثل :math:`uv` قطع شوند می توان یکی از یال های :math:`T ^ {\prime}` مثل :math:`u^{\prime}v^{\prime}` را به درخت :math:`T` اضافه کرد که ساختار همچنان همبند باقی بماند.

پس فرض کنید :math:`uv` را از :math:`T` حذف کردیم در اینصورت درخت ما دارای دو مولفه همبندی خواهد شد یکی از مولفه ها را آبی و دیگری را قرمز در نظر بگیرید. حالا می توان در درخت :math:`T^{\prime}` مسیری بین :math:`u,v` یافت.
در این مسیر یالی وجود خواهد داشت که یک سر آن آبی و یک سر آن قرمز باشد (چرا؟). حالا اگر این یال :math:`u^{\prime}v^{\prime}` باشد می توانیم این یال را به :math:`T` اضافه کنیم و دوباره آن را همبند کنیم!


افراز درخت به مسیر ها
-------------------------------

درخت :math:`T` را در نظر بگیرید. در این قسمت هدف ما این است که یال های این درخت را به کمترین تعداد تعدادی مسیر افراز کنیم. برای شهود بهتر فرض کنید یال های مسیر ها را یکی یکی از درخت حدف می کنیم تا به گرافی بدون یال برسیم.

اول از همه توجه کنید که بعد از حذف هر مسیر تنها زوجیت درجه دو سر مسیر تغییر می کند همچنین در انتها درجه تمام راس ها زوج (صفر) خواهد بود. پس یک راس درجه فرد باید فرد بار و یک راس درجه زوج باید زوج بار به عنوان یک سر مسیر انتخاب شود. پس اگر تعداد راس های درجه فرد درخت :math:`X` باشد آنگاه حداقل :math:`\frac X 2` مسیر نیاز داریم. (می دانیم که تعداد راس های درجه فرد هر گرافی زوج است پس :math:`X` زوج است). 

حالا اگر در هر مرحله مسیر بین دو راس درجه فرد را حذف کنیم می توانیم به حالت بهینه برسیم! فقط باید توجه داشته باشیم که دو راس درجه فرد ما مربوط به یک مولفه همبندی باشد.

حالا سوالی که پیش می آید این است که درخت بودن طی این فرایند به ما چه کمکی کرد؟

در نهایت ما از این موضوع استفاده کردیم که اگر درختی راس درجه فرد نداشته باشد یالی ندارد (اما این قضیه در گراف به صورت کلی برقرار نیست). چرا که اگر تعداد راس های گراف حداقل دو باشد در اینصورت برگی خواهد داشت که درجه آن 1 (و فرد) است.


پوشاندن یال های درخت با مسیر ها
-------------------------------

در ابن قسمت می خواهیم کمترین تعداد مسیر را پیدا کنیم که اجتماع آن ها کل یال های :math:`T` را شامل شود. این مسئله مشابه حالت قبل است با این تفاوت که در حالت قبل یال ها را به مسیر ها افراز می کردیم یعنی هر یال متعلق به یک مسیر بود. در اینجا این آزادی را داریم که یک مسیر چند بار یالی را بپوشاند. می توان نتیجه گرفت که جواب این مسئله کمتر از مسئله قبل است.

در نگاه اول متوجه می شوید که چون طولانی کردن مسیر ها ضرری با ما نمی زند پس حالت بهینه ای وجود دارد که دو سر هر مسیر برگ باشد!

از طرف دیگر به ازای هر برگ یالی که از این برگ به راس مجاورش می رود را در نظر بگیرید. هر مسیر حداکثر 2 تا از این یال ها را می پوشاند. پس اگر :math:`X` تا برگ داشته باشیم حداقل :math:`\frac X 2` تا مسیر نیاز داریم حالا تلاش می کنیم تا این کران را بر آورده کنیم. یعنی اگر :math:`X` زوج باشد با :math:`\frac X 2` مسیر و اگر :math:`X` فرد بود با :math:`\frac {X+1} 2` مسیر یال های درخت را بپوشانیم.

پس سعی می کنیم در هر مرحله پس از انتخاب مسیر درختمان را به درختی تبدیل کنیم که تعداد برگ هایش دو تا کمتر است(البته در حالتی که :math:`X` فرد باشد مرحله آخر نمی توانیم اینکار را بکنیم). اگر بتوانیم این کار را بکنیم تعداد مسیر هایی که انتخاب کردیم نصف تعداد برگ ها خواهد بود همانطور که می خواستیم.

دو برگ دلخواه مثل :math:`u,v` را در نظر بگیرید و درخت را از این مسیر آویزان کنید. ابتدا این مسیر را انتخاب کنید (که یال های بین :math:`u,v` را بپوشاند). فرض کنید راس های مسیر ما :math:`a_1,...,a_k` باشد حالا درختی می سازیم که به جای :math:`a_1,...,a_k` یک راس دارد! بین این راس و یک راس مثل :math:`w` یال است اگر و تنها اگر بین :math:`w` و یکی از :math:`a_1,...,a_k` یال باشد.‌ (به صورت شهودی مثل این است که کل راس های مسیر را فشرده کردیم و به یک راس تبدیل کردیم). حالا هر مسیر در گراف جدیدمان معادل با یک مسیر در گراف اولیه است و الان تنها کافیست کل یال ها در درخت جدید را با مسیر ها بپوشانیم! 

 .. figure:: /_static/compress.png
   :width: 50%
   :align: center
   :alt: اگه اینترنت یارو آشغال باشه این میاد

پس در هر مرحله یک مسیر که دو سر آن برگ است را فشرده می کنیم و به صورت یک راس در می آوریم. در هر مرحله تعداد برگ های گراف جدیدمان دو تا کم می شود مگر اینکه راسی که جدید اضافه کردیم (راس فشرده) برگ باشد. در صورتی این اتفاق می افتد که راس های مسیر بین :math:`u,v` همه درجه 2 باشند به جز یکی از آنها که باید درجه 3 باشد. به :math:`u,v` که مسیر بین آن چنین خاصیتی داشته باشد یک زوج ناسازگار می گوییم.

پس اگر بتوانیم در هر مرحله دو برگ :math:`u,v` را طوری انتخاب کنیم که زوج ناسازگار نباشند این کار را می کنیم (‌که پس از فشرده سازی از تعداد برگ ها 2 تا کم می کند). اگر نتوانستیم اینکار را بکنیم چه؟ در اینصورت ادعا می کنیم تنها یک راس درجه 3 داریم و باقی راس ها دارای درجه 1 یا 2 هستند (چرا؟). در اینصورت همانطور که در شکل می بینید درخت ما دقیقا 3 برگ خواهد داشت و می توانیم آن را با 2 مسیر بپوشانیم.

 .. figure:: /_static/sepaye.png
   :width: 50%
   :align: center
   :alt: اگه اینترنت یارو آشغال باشه این میاد

درخت چپانی
---------------

فرض کنید درختی :math:`n` راسی به نام :math:`T` داریم. همچنین گرافی مثل :math:`G` داریم که :math:`\delta(G) \geq n-1`. می خواهیم ثابت کنیم زیرمجموعه ای از یال های :math:`G` وجود دارد که :math:`T` را بسازد. (به صورت شهودی یک درخت :math:`T` در گراف :math:`G` بتوان پیدا کرد).

یک برگ دلخواه مثل :math:`u` که تنها مجاور آن :math:`v` است را در نظر بگیرید و :math:`u` را از درخت حذف کنید! سپس به صورت استقرایی درخت :math:`T-u` را در :math:`G` پیدا کنید. حالا می خواهیم یال :math:`uv` را به درختمان اضافه کنیم. فرض کنید راس :math:`v` در گراف :math:`G` متناظر با :math:`v^{\prime}` شده باشد. حالا کافیست از بین مجاور های :math:`v^{\prime}` راسی را انتخاب کنید که قبلا با هیچ راس درخت متناظر نشده است. سپس می توان این راس را متناظر با :math:`u` قرار داد که فرض استقرای ما را ثابت می کند.

برای یافتن چنین راسی کافیست از فرض :math:`\delta(G) \geq n-1` استفاده کنیم. پس :math:`v^{\prime}` حداقل :math:`n-1` مجاور دارد و حداکثر :math:`n-2` تا از آن ها قبلا به راس های درخت متناظر شده اند. پس یکی از مجاور های :math:`v` تا حالا به راس های درخت متناظر نشده که حالا می توانیم همانطور که گفتیم :math:`u` را به آن متناظر کنیم.

این مسئله به منظور آشنایی شما با ساختار استقرا پذیر درخت مطرح شد. دیدید که چطور می توان یک برگ از درخت را حذف کرد و فرض استقرا را برای درخت باقی مانده به کار برد.

درخت ها به عنوان اسکلت گراف

درخت فراگیر

پاک کردن هر یال مولفه ها رو زیاد میکنه. اضافه کردن یک یال دقیقا یک دور ایجاد می کنه.

min(diam(G, G`)) <= 3

not yet
