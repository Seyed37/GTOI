

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="rtl" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


    
         <title>الگوریتم پیدا کردن قطر درخت &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-rtl.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="درخت ها" href="index.html" />
        <link rel="next" title="الگوریتم های راس و یال برشی" href="8.html" />
        <link rel="prev" title="bfs" href="6.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-left " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="جستجو">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">تعاریف اولیه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">مقدمات و پیاده سازی گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">مدل سازی با گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">گشت، گذر، مسیر، اکسترمال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">همبندی، یال برشی و راس برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">زیر گراف ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">گراف دو بخشی</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">درخت ها</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">خاصیت های مقدماتی</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">فاصله در درخت و گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">شمردن تعداد درخت ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">dfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">bfs</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">الگوریتم پیدا کردن قطر درخت</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.html">الگوریتم های راس و یال برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="9.html">کارگاه پرورش ایده</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">گراف جهت‌دار</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">تعاریف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">تورنومنت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">گراف جهت‌دار بدون دور</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html">مولفه‌های قویا همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">تشخیص دور داشتن گراف جهت دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">بازی‌ها و گراف جهت‌دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">گراف تابعی و گراف جایگشت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../4/index.html">تکنیک های اثبات مسائل گراف</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../4/1.html">انتخاب های اکسترمالی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/2.html">منقبض کردن</a></li>
<li class="toctree-l2"><a class="reference internal" href="../4/3.html">گراف و جادو</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">تور اویلری و دور همیلتونی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">معرفی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">تور اویلری در گراف جهت دار و بی جهت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">قضیه های وجودی دور همیلتونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">الگوریتم های نمایی پیدا کردن دور و مسیر همیلتونی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">الگوریتم های کوتاه ترین مسیر</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">بلمن فورد</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">دکسترا</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">فلوید وارشال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/4.html">پیدا کردن دور منفی در گراف</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">ماتریس ها</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">ماتریس مجاورت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">تعداد گشت ها به طول n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">به دست آوردن توابع بازگشتی به کمک گراف و ماتریس</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">داده ساختار های درختی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">BST</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">Segment tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">MST</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">Kruskal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Prim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Buvrika</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">شرح مساله</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">راه حل O(n+q*lg(n)) به کمک جداسازی سبک-سنگین</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">الگوریتم برون‌خط تارجان</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">ارتباط LCA و RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">راه خطی برای LCA</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">الگوریتم های پیشرفته درخت</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">سنتروید</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">گونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">اچ ال دی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">هافمن کدینگ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">هش درخت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">همبندی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">برش ها و همبندی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">گراف k همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">برش کمینه و جریان بیشینه</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">تطابق</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">آشنایی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">تطابق در گراف دوبخشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">قضایا ی مینماکس</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">کاربرد ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">جریان بیشینه و تطابق</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">تطابق در گراف های عام</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">مباحث ویژه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">گراف مسطح</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">دنباله درجه ای</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">رنگ آمیزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">یک ریختی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">اعداد رمزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">چند جمله ای گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">مجموعه مستقل و خوشه</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">2sat</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">ضمیمه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">چگونه از این کتاب استفاده کنیم؟</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">آشنایی با الگوریتم ها و پیچیدگی</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; فهرست</a>&nbsp;
        <a><i class="fa  fa-angle-left"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; الگوریتم پیدا کردن قطر درخت</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;سوالات</a>
        
            <a href="../../_sources/book/2/7.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; سورس</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <div class="section" id="id1">
<h1>الگوریتم پیدا کردن قطر درخت<a class="headerlink" href="#id1" title="لینک ثابت به این سر مقاله">¶</a></h1>
<p>یکی دیگر از مسائلی که در حالت کلی گراف np است اما در درخت ها به سادگی حل می شود مسئله پیدا کردن بلندترین مسیر است! از آنجایی که در درخت ها مسیر بین هر دو راس یکتا است می توان نتیجه گرفت قطر درخت همان بلندترین مسیر درخت می باشد. در این بخش روش های پیدا کردن قطر درخت را با پیچیدگی زمانی <span class="math notranslate nohighlight">\(O(n)\)</span> بررسی می کنیم.</p>
<div class="section" id="dp">
<h2>استفاده از dp<a class="headerlink" href="#dp" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>درخت را از راس 1 ریشه دار کنید. با استفاده از برنامه نویسی پویا دو متغیر زیر را به ازای هر راس <span class="math notranslate nohighlight">\(u\)</span> به دست می آوریم.</p>
<ul class="simple">
<li>مقدار <span class="math notranslate nohighlight">\(dp_u\)</span> برابر است با بیشترین فاصله راس <span class="math notranslate nohighlight">\(u\)</span> با یک راس درون زیردرخت خود <span class="math notranslate nohighlight">\(u\)</span>.</li>
<li>مقدار <span class="math notranslate nohighlight">\(ans_u\)</span> برابر است با اندازه قطر در زیردرخت <span class="math notranslate nohighlight">\(u\)</span>.</li>
</ul>
<p>واضح است که جواب مسئله برابر است با <span class="math notranslate nohighlight">\(ans_1\)</span>. حالا تنها مسئله باقی مانده این است که چگونه این دو متغیر را به دست آوریم.</p>
<p>برای به دست آوردن <span class="math notranslate nohighlight">\(dp_u\)</span> کافی است توجه کنید که در اولین حرکت از <span class="math notranslate nohighlight">\(u\)</span> به یکی از بچه هایش می رویم. پس باید به بچه ای برویم که مقدار <span class="math notranslate nohighlight">\(dp\)</span> آن بیشینه است.</p>
<p>برای به دست آوردن <span class="math notranslate nohighlight">\(ans_u\)</span> حالت بندی کنید که راس <span class="math notranslate nohighlight">\(u\)</span> درون قطر باشد یا نباشد.</p>
<ul class="simple">
<li>اگر راس <span class="math notranslate nohighlight">\(u\)</span> درون قطر نباشد مقدار <span class="math notranslate nohighlight">\(ans_u\)</span> برابر با بیشینه <span class="math notranslate nohighlight">\(ans\)</span> بچه های <span class="math notranslate nohighlight">\(u\)</span> خواهد بود زیرا که قطر کاملا درون یکی از بچه ها خواهد بود.</li>
<li>در غیر اینصورت اگر راس <span class="math notranslate nohighlight">\(u\)</span> انتهای قطر باشد جواب برابر با <span class="math notranslate nohighlight">\(dp_u\)</span> خواهد بود.</li>
<li>در غیر اینصورت راس <span class="math notranslate nohighlight">\(u\)</span> باید وسط یک مسیر باشد. حالت بندی کنید که دو سر آن به کدام یکی از بچه ها برود. اگر به بچه <span class="math notranslate nohighlight">\(a, b\)</span> برود جواب برابر با <span class="math notranslate nohighlight">\(2 + dp_a + dp_b\)</span> خواهد بود. پس کافیست <span class="math notranslate nohighlight">\(a, b\)</span> را دو بچه ای انتخاب کنیم که مقدار <span class="math notranslate nohighlight">\(dp\)</span> آن ها بیشینه است.</li>
</ul>
<p>در کد زیر در <span class="math notranslate nohighlight">\(mx1, mx2\)</span> به ترتیب راس های با بیشترین <span class="math notranslate nohighlight">\(dp\)</span> را نگه داری می کنیم.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span> <span class="n">ans</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">par</span> <span class="o">=</span> <span class="mi">0</span><span class="p">){</span>
   <span class="kt">int</span> <span class="n">mx1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mx2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
   <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">y</span> <span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span>
       <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">par</span><span class="p">){</span>
           <span class="n">dfs</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
           <span class="n">dp</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">y</span><span class="p">]);</span>
           <span class="n">ans</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">ans</span><span class="p">[</span><span class="n">y</span><span class="p">]);</span>
           <span class="k">if</span><span class="p">(</span><span class="n">mx1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">dp</span><span class="p">[</span><span class="n">mx1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">y</span><span class="p">]){</span>
                <span class="n">mx2</span> <span class="o">=</span> <span class="n">mx1</span><span class="p">;</span>
                <span class="n">mx1</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
           <span class="p">}</span>
           <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">mx2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">dp</span><span class="p">[</span><span class="n">mx2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dp</span><span class="p">[</span><span class="n">y</span><span class="p">]){</span>
                <span class="n">mx2</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
           <span class="p">}</span>
       <span class="p">}</span>
   <span class="p">}</span>
   <span class="n">ans</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">u</span><span class="p">]);</span>
   <span class="k">if</span><span class="p">(</span><span class="n">mx1</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">mx2</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
        <span class="n">ans</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ans</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">mx1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">mx2</span><span class="p">]);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>پس توانستیم الگوریتمی ارائه دهیم که با پیچیدگی زمانی <span class="math notranslate nohighlight">\(O(n)\)</span> قطر درخت را پیدا می کند.</p>
</div>
<div class="section" id="dfs-up-down">
<h2>dfs up/down<a class="headerlink" href="#dfs-up-down" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>گاهی هدف ما به دست آوردن یک متغیر مثل <span class="math notranslate nohighlight">\(dp\)</span> به ازای هر راس درخت است اما حساب کردن مقدار <span class="math notranslate nohighlight">\(dp_u\)</span> نیاز به داشتن مقدار <span class="math notranslate nohighlight">\(dp\)</span> تمام مجاور های راس <span class="math notranslate nohighlight">\(u\)</span> (و نه فقط بچه های <span class="math notranslate nohighlight">\(u\)</span>) دارد.</p>
<p>ساده ترین مثال برای معرفی این تکنیک مسئله پیدا کردن بیشترین فاصله از هر راس است. فرض کنید می خواهیم به ازای هر راس <span class="math notranslate nohighlight">\(u\)</span> خروج از مرکز این راس را داشته باشیم. جواب راس <span class="math notranslate nohighlight">\(u\)</span> را <span class="math notranslate nohighlight">\(ans_u\)</span> بگیرید. برای به دست آوردن جواب یک راس می توان به راحتی درخت را از این ارتفاع آویزان کرد و در <span class="math notranslate nohighlight">\(O(n)\)</span> ارتفاع درخت را حساب کرد. اما آیا می توان مسئله را به ازای تمام راس با هم در <span class="math notranslate nohighlight">\(O(n)\)</span> حل کرد؟</p>
<p>اولین مشکل ما این است که چون حساب کردن جواب یک راس به داشتن جواب مجاور هایش نیاز دارد نمی دانیم که محاسبه را از کجا شروع کنیم!</p>
<p>درخت را از راس <span class="math notranslate nohighlight">\(u\)</span> ریشه دار کنید. شکاندن مسئله به دو بخش می تواند مفید باشد. فرض کنید <span class="math notranslate nohighlight">\(dpDown_u\)</span> برابر است با بیشترین فاصله از راس <span class="math notranslate nohighlight">\(u\)</span> به راسی درون زیردرخت راس <span class="math notranslate nohighlight">\(u\)</span>. همچنین <span class="math notranslate nohighlight">\(dpUp_u\)</span> برابر است با بیشترین فاصله از راس <span class="math notranslate nohighlight">\(u\)</span> به راسی خارج از زیردرخت راس <span class="math notranslate nohighlight">\(u\)</span> (یعنی در اولین گام باید به پدر <span class="math notranslate nohighlight">\(u\)</span> برویم). واضح است که جواب راس <span class="math notranslate nohighlight">\(u\)</span> برابر با بیشینه دو عدد <span class="math notranslate nohighlight">\(dpDown_u\)</span> و <span class="math notranslate nohighlight">\(dpUp_u\)</span> است.</p>
<p>همانطور که در قسمت بالا بررسی کردیم <span class="math notranslate nohighlight">\(dpDown_u\)</span> را می توان از روی <span class="math notranslate nohighlight">\(dpDown\)</span> بچه های راس <span class="math notranslate nohighlight">\(u\)</span> حساب کرد.</p>
<p>برای حساب کردن <span class="math notranslate nohighlight">\(dpUp_u\)</span> توجه کنید که بعد از اینکه از <span class="math notranslate nohighlight">\(u\)</span> به پدر <span class="math notranslate nohighlight">\(u\)</span> رفتیم می توانیم دو راه در پیش بگیریم.</p>
<ul class="simple">
<li>می توانیم باز هم به بالا برویم. در اینصورت جواب برابر با <span class="math notranslate nohighlight">\(1 + dpUp_{par}\)</span> است(فرض کنید <span class="math notranslate nohighlight">\(par\)</span> پدر راس <span class="math notranslate nohighlight">\(u\)</span> است).</li>
<li>می توانیم به پایین برویم یعنی به یکی از برادر های <span class="math notranslate nohighlight">\(u\)</span> مثل <span class="math notranslate nohighlight">\(w\)</span> بریم. سپس باید پایین برویم. در اینصورت جواب برابر با <span class="math notranslate nohighlight">\(2 + dpDown_w\)</span> می باشد.</li>
</ul>
<p>نکته کلیدی این است که نیاز نیست هر بار تمام برادر های <span class="math notranslate nohighlight">\(u\)</span> را بررسی کنیم که راس با <span class="math notranslate nohighlight">\(dpDown\)</span> بیشینه (همان <span class="math notranslate nohighlight">\(w\)</span> را پیدا کنیم). کافی است به ازای <span class="math notranslate nohighlight">\(par\)</span> تنها یک بار دو بچه ای که <span class="math notranslate nohighlight">\(dpDown\)</span> آن ها بیشینه است را به دست بیاوریم. همواره راس <span class="math notranslate nohighlight">\(w\)</span> یکی از دو بچه <span class="math notranslate nohighlight">\(par\)</span> است که <span class="math notranslate nohighlight">\(dpDown\)</span> آنها بیشینه است. (چرا؟)</p>
<p>پس فهمیدیم که به چه صورت باید متغیر ها را به دست بیاوریم. اما همچنان یک مشکل حل نشده باقی مانده است. به چه ترتیبی باید به دست آوردن مقادیر را انجام دهیم. برای به دست آوردن <span class="math notranslate nohighlight">\(dpDown\)</span> نیاز داریم که مقادیر بچه ها و برای به دست آوردن <span class="math notranslate nohighlight">\(dpUp\)</span> نیاز داریم که مقادیر پدر را داشته باشیم. پس از کدام یک باید شروع کنیم؟</p>
<p>جواب ساده و هوشمندانه است. می توانیم طی دومرحله مقادیر را به دست بیاوریم. یک بار <span class="math notranslate nohighlight">\(dpDown\)</span> ها را با استفاده از dfsDown و سپس <span class="math notranslate nohighlight">\(dpUp\)</span> ها را با استفاده از dfsUp به دست بیاوریم! نکته اینجاست که در dfsDown ابتدا مقدار بچه ها به دست می آیند سپس مقدار راس فعلی. اما در dfsUp ابتدا مقدار پدر به دست می آید سپس مقدار بچه ها از روی پدر به دست می آیند!</p>
<p>توجه کنید که در تابع dfsUp وقتی روی یک راس هستیم فرض کرده ایم که <span class="math notranslate nohighlight">\(dpUp\)</span> آن راس به دست آمده است و سپس <span class="math notranslate nohighlight">\(dpUp\)</span> بچه های آن را به دست می آوریم.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">dpUp</span><span class="p">[</span><span class="n">maxn</span><span class="p">],</span> <span class="n">dpDown</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dfsDown</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">par</span> <span class="o">=</span> <span class="mi">0</span><span class="p">){</span> <span class="c1">// aval bayad in taabe ra ejra konim</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">y</span> <span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">par</span><span class="p">){</span>
            <span class="n">dfsDown</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
            <span class="n">dpDown</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dpDown</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">dpDown</span><span class="p">[</span><span class="n">y</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">dfsUp</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">par</span> <span class="o">=</span> <span class="mi">0</span><span class="p">){</span>
   <span class="kt">int</span> <span class="n">mx1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mx2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
   <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">y</span> <span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span>
       <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">par</span><span class="p">){</span>
           <span class="k">if</span><span class="p">(</span><span class="n">mx1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">dpDown</span><span class="p">[</span><span class="n">mx1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dpDown</span><span class="p">[</span><span class="n">y</span><span class="p">]){</span>
                <span class="n">mx2</span> <span class="o">=</span> <span class="n">mx1</span><span class="p">;</span>
                <span class="n">mx1</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
           <span class="p">}</span>
           <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">mx2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">dpDown</span><span class="p">[</span><span class="n">mx2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dpDown</span><span class="p">[</span><span class="n">y</span><span class="p">]){</span>
                <span class="n">mx2</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
           <span class="p">}</span>
       <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">y</span> <span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span>
       <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">par</span><span class="p">){</span>
            <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">mx1</span><span class="p">){</span>
                <span class="n">dpUp</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">dpUp</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">mx2</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">dpUp</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dpUp</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">doDown</span><span class="p">[</span><span class="n">mx2</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="n">dpUp</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dpUp</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">doDown</span><span class="p">[</span><span class="n">mx1</span><span class="p">]</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">dfsUp</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h2>آویزان کردن از مرکز<a class="headerlink" href="#id2" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>با تعریف مرکز گراف در قسمت های قبل آشنا شدیم و فهمیدیم که مرکز یک درخت وسط قطر است. در نتیجه اگر طول قطر فرد بود تنها یک مرکز داریم و اگر طول قطر زوج بود دو مرکز داریم.</p>
<p>یک قطر دلخواه از درخت را مثل <span class="math notranslate nohighlight">\(AB\)</span> در نظر بگیرید.</p>
<ul class="simple">
<li>اگر طول قطر زوج بود <strong>راس</strong> وسط مسیر <span class="math notranslate nohighlight">\(AB\)</span> را <span class="math notranslate nohighlight">\(MID\)</span> بنامید.</li>
<li>اگر طول قطر فرد بود <strong>یال</strong> وسط مسیر <span class="math notranslate nohighlight">\(AB\)</span> را <span class="math notranslate nohighlight">\(MID\)</span> بنامید.</li>
</ul>
<p>حالا همانند شکل درخت را از <span class="math notranslate nohighlight">\(MID\)</span> آویزان کنید. در این قسمت به بررسی ویژگی های جالب این نوع ریشه دار کردن می پردازیم.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/center.png"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/center.png" style="width: 80%;" /></a>
</div>
<p>در ادامه فرض می کنیم که قطر درخت زوج است (و در نتیجه <span class="math notranslate nohighlight">\(MID\)</span> یک راس است). بررسی حالاتی که قطر فرد باشد به صورت مشابه امکان پذیر است. حتی برای جلوگیری از دو بار کاری می توان وسط هر یال یک راس اضافه کرد (در نتیجه طی کردن یک یال در گراف قبل معادل با طی کردن دو یال در گراف جدید است) و سپس از آنجایی که در گراف جدید تمام فاصله ها دو برابر می شوند، قطر گراف جدید نیز زوج خواهد شد.</p>
<p>پس حالا درخت را از راس <span class="math notranslate nohighlight">\(MID\)</span> ریشه دار در نظر میگیریم و همانطور که می بینید اگر مسیر <span class="math notranslate nohighlight">\(A, B\)</span> تا ریشه را در نظر بگیریم با هم اشتراکی نخواهند داشت (به جز در ریشه). همچنین واضح است که ارتفاع راس های <span class="math notranslate nohighlight">\(A, B\)</span> با هم برابر است این ارتفاع را <span class="math notranslate nohighlight">\(H\)</span> بنامید.</p>
<div class="section" id="id3">
<h3>لم 2.7.1<a class="headerlink" href="#id3" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>اگر ارتفاع راس <span class="math notranslate nohighlight">\(u\)</span> را <span class="math notranslate nohighlight">\(h(u)\)</span> در نظر بگیریم آنگاه مسیری به طول حداقل <span class="math notranslate nohighlight">\(h(u) + H\)</span> وجود دارد که یک سر آن <span class="math notranslate nohighlight">\(u\)</span> است.</p>
<p>زیرا که اگر از <span class="math notranslate nohighlight">\(u\)</span> به ریشه بروید حداکثر با یکی از دو مسیر <span class="math notranslate nohighlight">\(A\)</span> به ریشه و <span class="math notranslate nohighlight">\(B\)</span> به ریشه اشتراک خواهیم داشت پس می توان با ادامه دادن مسیرمان از ریشه به یکی از <span class="math notranslate nohighlight">\(A\)</span> یا <span class="math notranslate nohighlight">\(B\)</span> برویم.</p>
</div>
<div class="section" id="id4">
<h3>لم 2.7.2<a class="headerlink" href="#id4" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>ارتفاع درخت برابر با <span class="math notranslate nohighlight">\(H\)</span> است. زیرا از طرفی دو راس <span class="math notranslate nohighlight">\(A, B\)</span> ارتفاع <span class="math notranslate nohighlight">\(H\)</span> دارند.</p>
<p>حالا فرض خاف کنید که راسی مثل <span class="math notranslate nohighlight">\(u\)</span> باشد که <span class="math notranslate nohighlight">\(h(u) &gt; H\)</span> طبق لم 2.7.1 مسیری به طول <span class="math notranslate nohighlight">\(h(u) + H\)</span> در درخت وجود خواهد داشت که بیشتر از <span class="math notranslate nohighlight">\(2 \times H\)</span> است. از آن جایی که فرض کردیم <span class="math notranslate nohighlight">\(AB\)</span> قطر درخت است پس امکان ندارد که مسیری بیشتر از <span class="math notranslate nohighlight">\(2 \times H\)</span> در درخت وجود داشته باشد که با فرض خلف در تناقض است و در نهایت ثابت می کند که ارتفاع درخت برابر با <span class="math notranslate nohighlight">\(H\)</span> است.</p>
<p>از کنار هم گذاشتن لم 2.7.1 و لم 2.7.2 نتیجه می شود که خروج از مرکز هر راس مثل <span class="math notranslate nohighlight">\(u\)</span> برابر با <span class="math notranslate nohighlight">\(h(u) + H\)</span> می باشد یعنی فاصله راس <span class="math notranslate nohighlight">\(u\)</span> از یکی از دو سر قطر <span class="math notranslate nohighlight">\(AB\)</span> (که این موضوع را قبلا نیز ثابت کرده بودیم).</p>
<p>دلیل این موضوع این است که اولا طبق لم 2.7.1 این خروج از مرکز <span class="math notranslate nohighlight">\(u\)</span> حداقل <span class="math notranslate nohighlight">\(h(u)+H\)</span> است. از طرف دیگر از راس <span class="math notranslate nohighlight">\(u\)</span> حداکثر <span class="math notranslate nohighlight">\(h(u)\)</span> یال می توان بالا رفت و حداکثر <span class="math notranslate nohighlight">\(H\)</span> یال می توان پایین رفت (زیرا طبق 2.7.2 ارتفاع درخت <span class="math notranslate nohighlight">\(H\)</span> است). در نتیجه خروج از مرکز حداکثر <span class="math notranslate nohighlight">\(h(u) + H\)</span> است که در نهایت ثابت می کند  <span class="math notranslate nohighlight">\(\varepsilon{(u)} = h(u) + H\)</span>.</p>
</div>
<div class="section" id="id5">
<h3>قضیه 2.7.3<a class="headerlink" href="#id5" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>به راس هایی که می توانند یکی از دو سر قطر باشند <strong>راس قطری</strong> می گوییم. به راس هایی که ارتفاع آن ها <span class="math notranslate nohighlight">\(H\)</span> است <strong>راس های کف</strong> می گوییم. در اینجا ثابت می کنیم که یک راس قطری است اگر و فقط اگر کف باشد!</p>
<p>اگر راسی مثل <span class="math notranslate nohighlight">\(u\)</span> قطری باشد یعنی <span class="math notranslate nohighlight">\(\varepsilon{(u)} = 2 \times H\)</span> است. از آنجایی که <span class="math notranslate nohighlight">\(\varepsilon{(u)} = h(u) + H\)</span> می توان نتیجه گرفت که <span class="math notranslate nohighlight">\(h(u) = H\)</span> است که یعنی این راس کف است.</p>
<p>اگر راسی مثل <span class="math notranslate nohighlight">\(u\)</span> کف باشد یعنی <span class="math notranslate nohighlight">\(h(u) = H\)</span> است. طبق <span class="math notranslate nohighlight">\(\varepsilon{(u)} = h(u) + H\)</span> نتیجه می گیریم که <span class="math notranslate nohighlight">\(\varepsilon{(u)} = 2 \times H\)</span> است که یعنی این راس قطری است.</p>
</div>
</div>
<div class="section" id="id6">
<h2>یک الگوریتم ساده تر<a class="headerlink" href="#id6" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>طبق لم 2.7.1 یکی دور ترین راس از <span class="math notranslate nohighlight">\(u\)</span> یکی از راس های کف است. از آنجایی که طبق قضیه 2.7.3 هر راس کف یک راس قطری نیز هست می توانیم نتیجه بگیریم دورترین راس از <span class="math notranslate nohighlight">\(u\)</span> یک سر قطر است!</p>
<p>بنابراین اگر دورترین راس از <span class="math notranslate nohighlight">\(u\)</span> (که یک راس دلخواه است) را پیدا کنیم و آن را <span class="math notranslate nohighlight">\(A\)</span> بنامیم آنگاه <span class="math notranslate nohighlight">\(A\)</span> یک سر قطر است. پس دورترین راس از <span class="math notranslate nohighlight">\(A\)</span> را در نظر بگیرید و آن را <span class="math notranslate nohighlight">\(B\)</span> بنامید. مسیر <span class="math notranslate nohighlight">\(AB\)</span> قطر درخت است.</p>
<p>این قضایا به ما الگوریتم ساده تری برای پیدا کردن قطر درخت پیشنهاد می دهند که پیاده سازی آن را در زیر می بینید. تابع far در واقع دور ترین راس از راس شروع را بر می گرداند.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mf">1e5</span> <span class="o">+</span> <span class="mi">10</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">far</span><span class="p">(</span><span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">par</span> <span class="o">=</span> <span class="mi">0</span><span class="p">){</span>
   <span class="n">h</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
   <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="nl">y</span> <span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">]){</span>
       <span class="k">if</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">par</span><span class="p">){</span>
           <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">far</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
           <span class="k">if</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">h</span><span class="p">[</span><span class="n">ans</span><span class="p">])</span>
               <span class="n">ans</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
       <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="c1">// input</span>
    <span class="kt">int</span> <span class="n">A</span> <span class="o">=</span> <span class="n">far</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">B</span> <span class="o">=</span> <span class="n">far</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
    <span class="c1">// AB ghotr ast!</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="6.html" style="float:right;" title="bfs" accesskey="p"><i class="fa fa-chevron-right"></i>&nbsp; قبلی</a>
                    
                    
                    <a href="8.html" style="float:left;" title="الگوریتم های راس و یال برشی" accesskey="n">بعدی &nbsp;<i class="fa fa-chevron-left"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/"><img src="/_static/shaazzz_logo.png"></a>
            </div>
            <div id="text">
                <p>
                    این کتاب توسط 
                    <a href="/contributors">
                    مشارکت کنندگان شاززز
                    </a>
                    به وجود آمده است.
                </p>
                <p>
                    این کتاب عمومی است و تحت پروانه cc-by-sa در دسترس است.
                </p>
                    <p style="font-size: 13px;">
                        آخرین به روز رسانی در ژوئیهٔ 18, 2020.
                    </p>
                <p style="font-size: 13px;">
                    
                        ساخته شده به وسیله <a href="http://sphinx-doc.org/">Sphinx</a> (1.8.5) و <a href="https://github.com/saeiddrv/SphinxMinooTheme">تم مینو</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img src="/_static/cc-by-sa.png">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>