

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="rtl" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


    
         <title>فاصله در درخت و گراف &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-rtl.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="درخت ها" href="index.html" />
        <link rel="next" title="مرکز و قطر گراف" href="3.html" />
        <link rel="prev" title="خاصیت های مقدماتی" href="1.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-left " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="جستجو">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">تعاریف اولیه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">مقدمات و پیاده سازی گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">مدل سازی با گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">گشت، گذر، مسیر، اکسترمال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">همبندی، یال برشی و راس برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">زیر گراف ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">گراف دو بخشی</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">درخت ها</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">خاصیت های مقدماتی</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">فاصله در درخت و گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">مرکز و قطر گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">شمردن تعداد درخت ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">dfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="6.html">bfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">الگوریتم پیدا کردن قطر درخت</a></li>
<li class="toctree-l2"><a class="reference internal" href="8.html">الگوریتم های راس و یال برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="9.html">کارگاه پرورش ایده</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">گراف جهت‌دار</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">تعاریف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">تورنومنت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">مولفه‌های قویا همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html">بازی‌ها و گراف جهت‌دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">گراف جهت‌دار بدون دور</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">الگوریتم مسیر خاکستری</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">گراف تابعی و گراف جایگشت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">تور اویلری و دور همیلتونی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">معرفی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">تور اویلری در گراف جهت دار و بی جهت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">قضیه های وجودی دور همیلتونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">الگوریتم های نمایی پیدا کردن دور و مسیر همیلتونی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">الگوریتم های کوتاه ترین مسیر</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">بلمن فورد</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">دکسترا</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">فلوید وارشال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/4.html">پیدا کردن دور منفی در گراف</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">ماتریس ها</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">ماتریس مجاورت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">تعداد مسیر ها به طول n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">به دست آوردن توابع بازگشتی به کمک گراف و ماتریس</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">داده ساختار های درختی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">BST</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">Segment tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">MST</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">Kruskal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Prim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Buvrika</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">شرح مساله</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">راه حل O(n+q*lg(n)) به کمک جداسازی سبک-سنگین</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">الگوریتم برون‌خط تارجان</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">ارتباط LCA و RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">راه خطی برای LCA</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">الگوریتم های پیشرفته درخت</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">سنتروید</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">گونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">اچ ال دی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">هافمن کدینگ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">هش درخت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">همبندی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">برش ها و همبندی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">گراف k همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">برش کمینه و جریان بیشینه</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../13/index.html">تطابق</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../13/1.html">آشنایی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/2.html">تطابق در گراف دوبخشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/3.html">قضایا ی مینماکس</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/4.html">کاربرد ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/5.html">جریان بیشینه و تطابق</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/6.html">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../13/7.html">تطابق در گراف های عام</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">مباحث ویژه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">گراف مسطح</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">دنباله درجه ای</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">رنگ آمیزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">یک ریختی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">اعداد رمزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">چند جمله ای گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">مجموعه مستقل و خوشه</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">2sat</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">ضمیمه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">چگونه از این کتاب استفاده کنیم؟</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">آشنایی با الگوریتم ها و پیچیدگی</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; فهرست</a>&nbsp;
        <a><i class="fa  fa-angle-left"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; فاصله در درخت و گراف</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;سوالات</a>
        
            <a href="../../_sources/book/2/2.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; سورس</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <div class="section" id="id1">
<h1>فاصله در درخت و گراف<a class="headerlink" href="#id1" title="لینک ثابت به این سر مقاله">¶</a></h1>
<p>دو راس <span class="math notranslate nohighlight">\(u,v\)</span> در گراف را در نظر بگیرید. فاصله این دو راس طول (تعداد یال ها) کوتاه ترین مسیر بین این دو راس تعریف می شود. در درخت ها صحبت در مورد فاصله به مراتب راحت تر از گراف در حالت کلی است چرا که در درخت مسیر بین هر دو راس یکتا است.</p>
<p>قطر چیست؟</p>
<p>شعاع چیست؟</p>
<p>مرکز چیست؟</p>
<p>سنتروید چیست؟‌(در حالت کلی و در درخت)</p>
<p>خروج از مبدا چیست؟</p>
<p>بیشترین فاصله از هر راس یکی از دو سر قطر است.</p>
<div class="section" id="id2">
<h2>مجموع فاصله ها<a class="headerlink" href="#id2" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>فرض کنید در مسئله ای هدف مینیمم یا ماکسیمم کردن مجموع فاصله بین هر دو راس است فرض کنید به این مجموع چگالی گراف بگوییم. به صورت شهودی هر چه چگالی گراف کمتر باشد گراف جمع و جور تر و هر چه چگالی گراف بیشتر باشد گراف پهن و پخش تر است.</p>
<p>در ضمن برای اینکه فاصله تعریف شده باشد فرض کنید موضوع بحث ما گراف های همبند می باشد.</p>
<div class="section" id="id3">
<h3>کمینه کردن چگالی گراف<a class="headerlink" href="#id3" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>فاصله بین دو راس حداقل 1 است. و در گراف <span class="math notranslate nohighlight">\(K_n\)</span> فاصله بین هر دو راس دقیقا 1 است. پس کمترین چگالی ممکن در گراف <span class="math notranslate nohighlight">\(K_n\)</span> به دست می آید که برابر با <span class="math notranslate nohighlight">\(n \choose 2\)</span> می باشد.</p>
<p>حالا اگر دامنه بحث را به درخت ها محدود کنیم مسئله کمی سخت تر می شود. اما همچنان می توان اینگونه استنتاج کرد.</p>
<ul class="simple">
<li>دقیقا <span class="math notranslate nohighlight">\(n-1\)</span> جفت از راس ها هستند که فاصله اشان دقیقا 1 است. زیرا درخت <span class="math notranslate nohighlight">\(n-1\)</span> یال دارد.</li>
<li>هر جفتی از راس ها که به همدیگر یال ندارند دارای فاصله حداقل 2 هستند.</li>
</ul>
<p>در نتیجه کمترین چگالی ممکن حداقل <span class="math notranslate nohighlight">\(2 \times {n \choose 2} - (n-1)\)</span> می باشد و تنها مثالی که در حالت این کران صدق می کند حالتی است که فاصله بین هر دو راس <strong>حداکثر</strong> برابر با 2 است. تنها درختی که این ویژگی را دارد ستاره می باشد (همانطور که در عکس می بینید). زیرا که اگر در این گراف دو برگ باشند که پدر مشترک نداشته باشند در اینصورت فاصله آنها حداقل 3 خواهد بود.</p>
<blockquote>
<div><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/star.png"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/star.png" style="width: 50%;" /></a>
</div>
</div></blockquote>
</div>
<div class="section" id="id4">
<h3>بیشینه کردن چگالی گراف<a class="headerlink" href="#id4" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>در این حالت توجه کنید که اگر یالی را حذف کنیم و حذف این یال گراف را ناهمبند نکند باید اینکار را بکنیم. زیرا که حذف یال باعث بیشتر شدن چگالی می شود (چرا؟). پس گرافی که چگالی آن بیشینه است را باید در میان درخت ها جست و جو کرد (زیرا همانطور که گفتیم همه یال های آن باید برشی باشد).</p>
<p>حالا یک راس خاص مثل <span class="math notranslate nohighlight">\(u\)</span> را در نظر بگیرید. ادعا می کنیم جمع فواصل همه راس ها از <span class="math notranslate nohighlight">\(u\)</span> حداکثر برابر با <span class="math notranslate nohighlight">\(n \choose 2\)</span> است.</p>
<p>برای اثبات فرض کنید درخت را از <span class="math notranslate nohighlight">\(u\)</span> آویزان کرده ایم و به ازای هر ارتفاع می دانیم که چند راس در این ارتفاع قرار دارند و بیشترین ارتفاع <span class="math notranslate nohighlight">\(H\)</span> باشد. در اینصورت به ازای هر ارتفاعی از 0 تا <span class="math notranslate nohighlight">\(H\)</span> حداقل یک راس از این ارتفاع باید داشته باشیم. حالا اگر حداقل دو راس در یک ارتفاع داشتیم می توان یکی از آن ها را به ارتفاع بالاتر برد و در اینصورت جمع ارتفاع ها بیشتر خواهد شد. با تکرار این فرایند به حالتی می رسیم که در هر ارتفاع 0 تا <span class="math notranslate nohighlight">\(n-1\)</span> دقیقا یک راس باشد (یعنی درخت یک مسیر شده) که در این حالت جمع فاصله ها از <span class="math notranslate nohighlight">\(u\)</span> برابر با <span class="math notranslate nohighlight">\(1 + 2 + ... + (n-1) = {n \choose 2}\)</span> خواهد بود. پس ثابت کردیم که جمع فاصله ها از هر راس <span class="math notranslate nohighlight">\(u\)</span> حداکثر <span class="math notranslate nohighlight">\(n \choose 2\)</span> است.</p>
<p>پس حالا برای اینکه به یک کران برسیم در هر مرحله یک <strong>برگ</strong> را از درخت حذف کنید و جمع فاصله ها از این برگ را محاسبه کنید. جمع تمام مقادیر برابر با چگالی گراف خواهد بود که طبق آنچه گفتیم حداکثر <span class="math notranslate nohighlight">\(\sum\limits_{i=1}^{n} {i \choose 2} = {{n+1} \choose 3}\)</span> خواهد بود (طبق اتحاد چوشی چی).</p>
<p>می توان نتیجه گرفت تنها گرافی که در حالت تساوی این کران صدق می کند گراف مسیر است.</p>
</div>
</div>
<div class="section" id="id5">
<h2>درخت پشتیبانی<a class="headerlink" href="#id5" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>فرض کنید یک شبکه ارتباطی داریم که <span class="math notranslate nohighlight">\(n\)</span> شهر را به هم وصل می کنند. برای اطمینان یک شبکه ارتباطی پشتیبانی هم آماده کرده ایم که در صورت ایجاد اختلال در شبکه اصلی از شبکه پشتیبانی استفاده کنیم تا ارتباط قطع نشود.</p>
<p>به زبان گراف دو درخت <span class="math notranslate nohighlight">\(n\)</span> راسی <span class="math notranslate nohighlight">\(T\)</span> و <span class="math notranslate nohighlight">\(T ^ {\prime}\)</span> داریم. می خواهیم ثابت کنیم در صورتیکه یکی از یال های <span class="math notranslate nohighlight">\(T\)</span> مثل <span class="math notranslate nohighlight">\(uv\)</span> قطع شوند می توان یکی از یال های <span class="math notranslate nohighlight">\(T ^ {\prime}\)</span> مثل <span class="math notranslate nohighlight">\(u^{\prime}v^{\prime}\)</span> را به درخت <span class="math notranslate nohighlight">\(T\)</span> اضافه کرد که ساختار همچنان همبند باقی بماند.</p>
<p>پس فرض کنید <span class="math notranslate nohighlight">\(uv\)</span> را از <span class="math notranslate nohighlight">\(T\)</span> حذف کردیم در اینصورت درخت ما دارای دو مولفه همبندی خواهد شد یکی از مولفه ها را آبی و دیگری را قرمز در نظر بگیرید. حالا می توان در درخت <span class="math notranslate nohighlight">\(T^{\prime}\)</span> مسیری بین <span class="math notranslate nohighlight">\(u,v\)</span> یافت.
در این مسیر یالی وجود خواهد داشت که یک سر آن آبی و یک سر آن قرمز باشد (چرا؟). حالا اگر این یال <span class="math notranslate nohighlight">\(u^{\prime}v^{\prime}\)</span> باشد می توانیم این یال را به <span class="math notranslate nohighlight">\(T\)</span> اضافه کنیم و دوباره آن را همبند کنیم!</p>
</div>
<div class="section" id="id6">
<h2>افراز درخت به مسیر ها<a class="headerlink" href="#id6" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>درخت <span class="math notranslate nohighlight">\(T\)</span> را در نظر بگیرید. در این قسمت هدف ما این است که یال های این درخت را به کمترین تعداد تعدادی مسیر افراز کنیم. برای شهود بهتر فرض کنید یال های مسیر ها را یکی یکی از درخت حدف می کنیم تا به گرافی بدون یال برسیم.</p>
<p>اول از همه توجه کنید که بعد از حذف هر مسیر تنها زوجیت درجه دو سر مسیر تغییر می کند همچنین در انتها درجه تمام راس ها زوج (صفر) خواهد بود. پس یک راس درجه فرد باید فرد بار و یک راس درجه زوج باید زوج بار به عنوان یک سر مسیر انتخاب شود. پس اگر تعداد راس های درجه فرد درخت <span class="math notranslate nohighlight">\(X\)</span> باشد آنگاه حداقل <span class="math notranslate nohighlight">\(\frac X 2\)</span> مسیر نیاز داریم. (می دانیم که تعداد راس های درجه فرد هر گرافی زوج است پس <span class="math notranslate nohighlight">\(X\)</span> زوج است).</p>
<p>حالا اگر در هر مرحله مسیر بین دو راس درجه فرد را حذف کنیم می توانیم به حالت بهینه برسیم! فقط باید توجه داشته باشیم که دو راس درجه فرد ما مربوط به یک مولفه همبندی باشد.</p>
<p>حالا سوالی که پیش می آید این است که درخت بودن طی این فرایند به ما چه کمکی کرد؟</p>
<p>در نهایت ما از این موضوع استفاده کردیم که اگر درختی راس درجه فرد نداشته باشد یالی ندارد (اما این قضیه در گراف به صورت کلی برقرار نیست). چرا که اگر تعداد راس های گراف حداقل دو باشد در اینصورت برگی خواهد داشت که درجه آن 1 (و فرد) است.</p>
</div>
<div class="section" id="id7">
<h2>پوشاندن یال های درخت با مسیر ها<a class="headerlink" href="#id7" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>در ابن قسمت می خواهیم کمترین تعداد مسیر را پیدا کنیم که اجتماع آن ها کل یال های <span class="math notranslate nohighlight">\(T\)</span> را شامل شود. این مسئله مشابه حالت قبل است با این تفاوت که در حالت قبل یال ها را به مسیر ها افراز می کردیم یعنی هر یال متعلق به یک مسیر بود. در اینجا این آزادی را داریم که یک مسیر چند بار یالی را بپوشاند. می توان نتیجه گرفت که جواب این مسئله کمتر از مسئله قبل است.</p>
<p>در نگاه اول متوجه می شوید که چون طولانی کردن مسیر ها ضرری با ما نمی زند پس حالت بهینه ای وجود دارد که دو سر هر مسیر برگ باشد!</p>
<p>از طرف دیگر به ازای هر برگ یالی که از این برگ به راس مجاورش می رود را در نظر بگیرید. هر مسیر حداکثر 2 تا از این یال ها را می پوشاند. پس اگر <span class="math notranslate nohighlight">\(X\)</span> تا برگ داشته باشیم حداقل <span class="math notranslate nohighlight">\(\frac X 2\)</span> تا مسیر نیاز داریم حالا تلاش می کنیم تا این کران را بر آورده کنیم. یعنی اگر <span class="math notranslate nohighlight">\(X\)</span> زوج باشد با <span class="math notranslate nohighlight">\(\frac X 2\)</span> مسیر و اگر <span class="math notranslate nohighlight">\(X\)</span> فرد بود با <span class="math notranslate nohighlight">\(\frac {X+1} 2\)</span> مسیر یال های درخت را بپوشانیم.</p>
<p>پس سعی می کنیم در هر مرحله پس از انتخاب مسیر درختمان را به درختی تبدیل کنیم که تعداد برگ هایش دو تا کمتر است(البته در حالتی که <span class="math notranslate nohighlight">\(X\)</span> فرد باشد مرحله آخر نمی توانیم اینکار را بکنیم). اگر بتوانیم این کار را بکنیم تعداد مسیر هایی که انتخاب کردیم نصف تعداد برگ ها خواهد بود همانطور که می خواستیم.</p>
<p>دو برگ دلخواه مثل <span class="math notranslate nohighlight">\(u,v\)</span> را در نظر بگیرید و درخت را از این مسیر آویزان کنید. ابتدا این مسیر را انتخاب کنید (که یال های بین <span class="math notranslate nohighlight">\(u,v\)</span> را بپوشاند). فرض کنید راس های مسیر ما <span class="math notranslate nohighlight">\(a_1,...,a_k\)</span> باشد حالا درختی می سازیم که به جای <span class="math notranslate nohighlight">\(a_1,...,a_k\)</span> یک راس دارد! بین این راس و یک راس مثل <span class="math notranslate nohighlight">\(w\)</span> یال است اگر و تنها اگر بین <span class="math notranslate nohighlight">\(w\)</span> و یکی از <span class="math notranslate nohighlight">\(a_1,...,a_k\)</span> یال باشد.‌ (به صورت شهودی مثل این است که کل راس های مسیر را فشرده کردیم و به یک راس تبدیل کردیم). حالا هر مسیر در گراف جدیدمان معادل با یک مسیر در گراف اولیه است و الان تنها کافیست کل یال ها در درخت جدید را با مسیر ها بپوشانیم!</p>
<blockquote>
<div><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/compress.png"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/compress.png" style="width: 50%;" /></a>
</div>
</div></blockquote>
<p>پس در هر مرحله یک مسیر که دو سر آن برگ است را فشرده می کنیم و به صورت یک راس در می آوریم. در هر مرحله تعداد برگ های گراف جدیدمان دو تا کم می شود مگر اینکه راسی که جدید اضافه کردیم (راس فشرده) برگ باشد. در صورتی این اتفاق می افتد که راس های مسیر بین <span class="math notranslate nohighlight">\(u,v\)</span> همه درجه 2 باشند به جز یکی از آنها که باید درجه 3 باشد. به <span class="math notranslate nohighlight">\(u,v\)</span> که مسیر بین آن چنین خاصیتی داشته باشد یک زوج ناسازگار می گوییم.</p>
<p>پس اگر بتوانیم در هر مرحله دو برگ <span class="math notranslate nohighlight">\(u,v\)</span> را طوری انتخاب کنیم که زوج ناسازگار نباشند این کار را می کنیم (‌که پس از فشرده سازی از تعداد برگ ها 2 تا کم می کند). اگر نتوانستیم اینکار را بکنیم چه؟ در اینصورت ادعا می کنیم تنها یک راس درجه 3 داریم و باقی راس ها دارای درجه 1 یا 2 هستند (چرا؟). در اینصورت همانطور که در شکل می بینید درخت ما دقیقا 3 برگ خواهد داشت و می توانیم آن را با 2 مسیر بپوشانیم.</p>
<blockquote>
<div><div class="figure align-center">
<a class="reference internal image-reference" href="../../_images/sepaye.png"><img alt="اگه اینترنت یارو آشغال باشه این میاد" src="../../_images/sepaye.png" style="width: 50%;" /></a>
</div>
</div></blockquote>
</div>
<div class="section" id="id8">
<h2>درخت چپانی<a class="headerlink" href="#id8" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>فرض کنید درختی <span class="math notranslate nohighlight">\(n\)</span> راسی به نام <span class="math notranslate nohighlight">\(T\)</span> داریم. همچنین گرافی مثل <span class="math notranslate nohighlight">\(G\)</span> داریم که <span class="math notranslate nohighlight">\(\delta(G) \geq n-1\)</span>. می خواهیم ثابت کنیم زیرمجموعه ای از یال های <span class="math notranslate nohighlight">\(G\)</span> وجود دارد که <span class="math notranslate nohighlight">\(T\)</span> را بسازد. (به صورت شهودی یک درخت <span class="math notranslate nohighlight">\(T\)</span> در گراف <span class="math notranslate nohighlight">\(G\)</span> بتوان پیدا کرد).</p>
<p>یک برگ دلخواه مثل <span class="math notranslate nohighlight">\(u\)</span> که تنها مجاور آن <span class="math notranslate nohighlight">\(v\)</span> است را در نظر بگیرید و <span class="math notranslate nohighlight">\(u\)</span> را از درخت حذف کنید! سپس به صورت استقرایی درخت <span class="math notranslate nohighlight">\(T-u\)</span> را در <span class="math notranslate nohighlight">\(G\)</span> پیدا کنید. حالا می خواهیم یال <span class="math notranslate nohighlight">\(uv\)</span> را به درختمان اضافه کنیم. فرض کنید راس <span class="math notranslate nohighlight">\(v\)</span> در گراف <span class="math notranslate nohighlight">\(G\)</span> متناظر با <span class="math notranslate nohighlight">\(v^{\prime}\)</span> شده باشد. حالا کافیست از بین مجاور های <span class="math notranslate nohighlight">\(v^{\prime}\)</span> راسی را انتخاب کنید که قبلا با هیچ راس درخت متناظر نشده است. سپس می توان این راس را متناظر با <span class="math notranslate nohighlight">\(u\)</span> قرار داد که فرض استقرای ما را ثابت می کند.</p>
<p>برای یافتن چنین راسی کافیست از فرض <span class="math notranslate nohighlight">\(\delta(G) \geq n-1\)</span> استفاده کنیم. پس <span class="math notranslate nohighlight">\(v^{\prime}\)</span> حداقل <span class="math notranslate nohighlight">\(n-1\)</span> مجاور دارد و حداکثر <span class="math notranslate nohighlight">\(n-2\)</span> تا از آن ها قبلا به راس های درخت متناظر شده اند. پس یکی از مجاور های <span class="math notranslate nohighlight">\(v\)</span> تا حالا به راس های درخت متناظر نشده که حالا می توانیم همانطور که گفتیم <span class="math notranslate nohighlight">\(u\)</span> را به آن متناظر کنیم.</p>
<p>این مسئله به منظور آشنایی شما با ساختار استقرا پذیر درخت مطرح شد. دیدید که چطور می توان یک برگ از درخت را حذف کرد و فرض استقرا را برای درخت باقی مانده به کار برد.</p>
<p>درخت ها به عنوان اسکلت گراف</p>
<p>درخت فراگیر</p>
<p>پاک کردن هر یال مولفه ها رو زیاد میکنه. اضافه کردن یک یال دقیقا یک دور ایجاد می کنه.</p>
<p>min(diam(G, G`)) &lt;= 3</p>
<p>not yet</p>
</div>
</div>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="1.html" style="float:right;" title="خاصیت های مقدماتی" accesskey="p"><i class="fa fa-chevron-right"></i>&nbsp; قبلی</a>
                    
                    
                    <a href="3.html" style="float:left;" title="مرکز و قطر گراف" accesskey="n">بعدی &nbsp;<i class="fa fa-chevron-left"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/"><img src="/_static/shaazzz_logo.png"></a>
            </div>
            <div id="text">
                <p>
                    این کتاب توسط 
                    <a href="/contributors">
                    مشارکت کنندگان شاززز
                    </a>
                    به وجود آمده است.
                </p>
                <p>
                    این کتاب عمومی است و تحت پروانه cc-by-sa در دسترس است.
                </p>
                    <p style="font-size: 13px;">
                        آخرین به روز رسانی در آوریل 29, 2020.
                    </p>
                <p style="font-size: 13px;">
                    
                        ساخته شده به وسیله <a href="http://sphinx-doc.org/">Sphinx</a> (1.8.5) و <a href="https://github.com/saeiddrv/SphinxMinooTheme">تم مینو</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img src="/_static/cc-by-sa.png">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>