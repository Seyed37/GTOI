

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="fa" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="fa" > <!--<![endif]-->
<html dir="rtl" lang="fa">
    <head>
        
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


    
         <title>Poset &mdash; نظریه گراف‌ها برای المپیاد کامپیوتر</title>
    




    

    <link rel="stylesheet" type=text/css href="/_static/main.css">



<link rel="stylesheet" type=text/css href="../../_static/font-awesome.min.css">
<link rel="stylesheet" type=text/css href="../../_static/bootstrap.min.css">
<link rel="stylesheet" type=text/css href="../../_static/pygment-solarized-light.css">


    <link rel="stylesheet" type=text/css href="../../_static/minoo-rtl.css">

        <link rel="index" title="فهرست" href="../../genindex.html" />
        <link rel="search" title="جستجو" href="../../search.html" />
        <link rel="top" title="نظریه گراف‌ها برای المپیاد کامپیوتر" href="../../index.html" />
        <link rel="up" title="تطابق" href="index.html" />
        <link rel="next" title="تطابق در گراف های عام" href="7.html" />
        <link rel="prev" title="جریان بیشینه و تطابق" href="5.html" />



    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>

    
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
        <script type="text/javascript" src="../../_static/searchtools.js"></script>


<script type="text/javascript" src="../../_static/minoo.js"></script>
<script type="text/javascript" src="../../_static/modernizr.min.js"></script>
    </head>
    <body>
        <div id="page">
            <div id="wrapper-page-sidebar">
                

<div id="page-sidebar">
<div id="sidebar-top">
    <div id="sidebar-top-image">
        <span style="background-image: url('../../_static/avatar.png');"></span>
    </div>
    <div id="sidebar-top-links">
        
            <a href=http://git.coderz.ir target="_blank"><i class="fa fa-globe" style="font-size:23px;"></i></a>
        
        
        
        
        
        
            <a href=https://github.com/dariubs/git target="_blank"><i class="fa fa-github-square" style="font-size:23px;"></i></a>
        
        
    </div>
    <div id="sidebar-navigation">
        <span id="navigation-toggle"><i class="fa  fa-angle-double-left " id="sidebar-toggle-icon" style="font-size: 27px;"></i></span>
        <span id="navigation-search">
                <form action="../../search.html" method="get">
                    <input id="input-search" type="text" name="q"  placeholder="جستجو">
                    <input type="hidden" name="check_keywords" value="yes" />
                    <input type="hidden" name="area" value="default" />
                </form>
        </span>
    </div>
    <div id="sidebar-top-title">
        <a href="../../index.html">نظریه گراف‌ها برای المپیاد کامپیوتر</a>
    </div>
</div>

<div id="wrapper-sidebar-bottom">
<div id="sidebar-bottom">
    <div id="sidebar-bottom-list">
        
        
            <div id="tree-toc">
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1/index.html">تعاریف اولیه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../1/1.html">مقدمات و پیاده سازی گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/2.html">مدل سازی با گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/3.html">گشت، گذر، مسیر، اکسترمال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/4.html">همبندی، یال برشی و راس برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/5.html">زیر گراف ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../1/6.html">گراف دو بخشی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../2/index.html">درخت ها</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../2/1.html">خاصیت های مقدماتی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/2.html">فاصله در درخت و گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/3.html">مرکز و قطر گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/4.html">شمردن تعداد درخت ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/5.html">dfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/6.html">bfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/7.html">الگوریتم پیدا کردن قطر درخت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/8.html">الگوریتم های راس و یال برشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../2/9.html">کارگاه پرورش ایده</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3/index.html">گراف جهت‌دار</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../3/1.html">تعاریف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/2.html">تورنومنت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/3.html">مولفه‌های قویا همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/4.html">بازی‌ها و گراف جهت‌دار</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/5.html">گراف جهت‌دار بدون دور</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/6.html">الگوریتم مسیر خاکستری</a></li>
<li class="toctree-l2"><a class="reference internal" href="../3/7.html">گراف تابعی و گراف جایگشت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../5/index.html">تور اویلری و دور همیلتونی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../5/1.html">معرفی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/2.html">تور اویلری در گراف جهت دار و بی جهت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/3.html">De Bruijn sequence</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/4.html">قضیه های وجودی دور همیلتونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../5/5.html">الگوریتم های نمایی پیدا کردن دور و مسیر همیلتونی</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../6/index.html">الگوریتم های کوتاه ترین مسیر</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../6/1.html">بلمن فورد</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/2.html">دکسترا</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/3.html">فلوید وارشال</a></li>
<li class="toctree-l2"><a class="reference internal" href="../6/4.html">پیدا کردن دور منفی در گراف</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../7/index.html">ماتریس ها</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../7/1.html">ماتریس مجاورت</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/2.html">تعداد مسیر ها به طول n</a></li>
<li class="toctree-l2"><a class="reference internal" href="../7/3.html">به دست آوردن توابع بازگشتی به کمک گراف و ماتریس</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8/index.html">داده ساختار های درختی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../8/1.html">BST</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/2.html">heap</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/3.html">DSU</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/4.html">Segment tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../8/5.html">trie</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../9/index.html">MST</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../9/1.html">Kruskal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/2.html">Prim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../9/3.html">Buvrika</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10/index.html">Lca</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../10/1.html">شرح مساله</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/2.html">راه حل O(n+q*lg(n)) به کمک جداسازی سبک-سنگین</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/3.html">الگوریتم برون‌خط تارجان</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/4.html">ارتباط LCA و RMQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../10/5.html">راه خطی برای LCA</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../11/index.html">الگوریتم های پیشرفته درخت</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../11/1.html">سنتروید</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/2.html">گونی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/3.html">اچ ال دی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/4.html">هافمن کدینگ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../11/5.html">هش درخت</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../12/index.html">همبندی</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../12/1.html">برش ها و همبندی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/2.html">گراف k همبند</a></li>
<li class="toctree-l2"><a class="reference internal" href="../12/3.html">برش کمینه و جریان بیشینه</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">تطابق</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="1.html">آشنایی</a></li>
<li class="toctree-l2"><a class="reference internal" href="2.html">تطابق در گراف دوبخشی</a></li>
<li class="toctree-l2"><a class="reference internal" href="3.html">قضایا ی مینماکس</a></li>
<li class="toctree-l2"><a class="reference internal" href="4.html">کاربرد ها</a></li>
<li class="toctree-l2"><a class="reference internal" href="5.html">جریان بیشینه و تطابق</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Poset</a></li>
<li class="toctree-l2"><a class="reference internal" href="7.html">تطابق در گراف های عام</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14/index.html">مباحث ویژه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../14/1.html">گراف مسطح</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/2.html">دنباله درجه ای</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/3.html">رنگ آمیزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/4.html">یک ریختی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/5.html">Random Walk</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/6.html">اعداد رمزی</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/7.html">چند جمله ای گراف</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/8.html">مجموعه مستقل و خوشه</a></li>
<li class="toctree-l2"><a class="reference internal" href="../14/9.html">2sat</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../appendix/index.html">ضمیمه</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../appendix/1.html">چگونه از این کتاب استفاده کنیم؟</a></li>
<li class="toctree-l2"><a class="reference internal" href="../appendix/2.html">آشنایی با الگوریتم ها و پیچیدگی</a></li>
</ul>
</li>
</ul>

            </div>
        
   </div>
   <div id="sidebar-bottom-versions">
      

   </div>
</div>
</div>
</div>
            </div>
            <div id="page-body">
                <div class="container-fluid">
                        <div id="body-content" style="max-width: 800px">

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

<div id="body-top">
    
    
        <a href="../../index.html"><i class="fa fa-folder-o"></i>&nbsp; فهرست</a>&nbsp;
        <a><i class="fa  fa-angle-left"></i></a>&nbsp;
        <a><i class="fa fa-folder-open-o"></i>&nbsp; Poset</a>
    
    
        <a style="float: left; padding-right: 20px;" href="/problems/" id="problems-link"><i class="fa fa-question on fa-circle"></i>&nbsp;سوالات</a>
        
            <a href="../../_sources/book/13/6.rst.txt" rel="nofollow" id="top-src" target="_blank"><i class="fa fa-code"></i>&nbsp; سورس</a>
        
    
</div>
			        </div>
			    </div>
                            
                            <div class="row-fluid">
			        <div class="col-lg-12">
				    
  <div class="section" id="poset">
<h1>Poset<a class="headerlink" href="#poset" title="لینک ثابت به این سر مقاله">¶</a></h1>
<div class="section" id="id1">
<h2>تعریف<a class="headerlink" href="#id1" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>به گراف جهت داری که دارای ویژگی زیر باشد Poset (Partially ordered set) می گوییم.</p>
<ul class="simple">
<li>اگر <span class="math notranslate nohighlight">\(ab\)</span> و <span class="math notranslate nohighlight">\(bc\)</span> یال های این گراف باشد آنگاه <span class="math notranslate nohighlight">\(ac\)</span> هم یال این گراف است.</li>
</ul>
<p>از آنجایی که بسیاری از مفاهیم ریاضی به poset تبدیل می شوند بررسی کردن آن ها مفید است.</p>
<div class="section" id="id2">
<h3>اولین مسئله<a class="headerlink" href="#id2" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>فرض کنید مجموعه ای از اعداد طبیعی مثل <span class="math notranslate nohighlight">\(A\)</span> داریم و می خواهیم بزرگترین زیرمجموعه ای از آن مثل <span class="math notranslate nohighlight">\(B\)</span> را پیدا کنیم که هر دو عضو <span class="math notranslate nohighlight">\(B\)</span> را که در نظر بگیریم یکی بر دیگری بخش پذیر است.</p>
<p>می توانیم مسئله را به اینصورت به گراف مدل کنیم. به ازای هر عضو <span class="math notranslate nohighlight">\(A\)</span> یک راس در گراف قرار دهید و به ازای دو راس <span class="math notranslate nohighlight">\(x,y\)</span> که <span class="math notranslate nohighlight">\(x|y\)</span> است از <span class="math notranslate nohighlight">\(x\)</span> به <span class="math notranslate nohighlight">\(y\)</span> یال بگذارید. حالا مسئله معادل پیدا کردن بلندترین مسیر در این گراف است!</p>
</div>
<div class="section" id="id3">
<h3>زنجیر و پادزنجیر<a class="headerlink" href="#id3" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>به یک دنباله از راس های غیر تکراری مثل <span class="math notranslate nohighlight">\(u_1,...,u_k\)</span> که به ازای هر <span class="math notranslate nohighlight">\(i&lt;j\)</span> ، <span class="math notranslate nohighlight">\(u_i\)</span> به <span class="math notranslate nohighlight">\(u_j\)</span> یال داشته باشد یک زنجیر می گوییم توجه کنید که به خاطر ویژگی poset کافیست که <span class="math notranslate nohighlight">\(u_1, ... u_k\)</span> یک مسیر باشد.</p>
<p>به یک زیرمجموعه از راس ها که هیچ دوتایی به هم یال نداشته باشند یک پادزنجیر می گوییم.</p>
<p>در ادامه افراز یک گراف به زنجیر ها یا پادزنجیر ها را بررسی خواهیم کرد (افراز راس های گراف مد نظر است).</p>
<p>توجه کنید که از این تعاریف تنها در poset ها استفاده می شود.</p>
</div>
</div>
<div class="section" id="id4">
<h2>ماکسیمم زنجیر = مینیمم افراز به پادزنجیر<a class="headerlink" href="#id4" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>فرض کنید اندازه ماکسیمم زنجیر <span class="math notranslate nohighlight">\(L\)</span> باشد. و یک زنجیر ماکسیمم مثل <span class="math notranslate nohighlight">\(A\)</span> را در نظر بگیرید.</p>
<p>هر پادزنجیر می تواند حداکثر یکی از راس های <span class="math notranslate nohighlight">\(A\)</span> را شامل شود. پس مینیمم افراز به پادزنجیر حداقل به اندازه <span class="math notranslate nohighlight">\(L\)</span> می باشد. حالا ثابت می کنیم حالتی از تساوی هم وجود دارد.</p>
<p>به هر راس <span class="math notranslate nohighlight">\(u\)</span> عدد <span class="math notranslate nohighlight">\(a_i\)</span> را نسبت می دهیم که برابر است با اندازه بزرگترین زنجیری که <span class="math notranslate nohighlight">\(u\)</span> انتهای آن باشد. حالا می توانید ببینید که اگر <span class="math notranslate nohighlight">\(a_i = a_j\)</span> برقرار باشد امکان ندارد یالی بین <span class="math notranslate nohighlight">\(i,j\)</span> باشد زیرا به عنوان مثال اگر از <span class="math notranslate nohighlight">\(i\)</span> به <span class="math notranslate nohighlight">\(j\)</span> یال باشد آنگاه <span class="math notranslate nohighlight">\(a_j \geq a_i+1\)</span> خواهد بود.</p>
<p>به ازای هر راس <span class="math notranslate nohighlight">\(u\)</span> به <span class="math notranslate nohighlight">\(a_u\)</span> رنگ راس <span class="math notranslate nohighlight">\(u\)</span> می گوییم. طبق اثبات بالا راس هایی که رنگ برابر دارند یک پادزنجیر هستند. همچنین تعداد رنگ ها برابر است با <span class="math notranslate nohighlight">\(L\)</span> (چرا؟). پس توانستیم گراف را به <span class="math notranslate nohighlight">\(L\)</span> پادزنجیر افراز کنیم.</p>
<p>قضیه یالا به قضیه میرسکی معروف است و در سال 1971 مطرح شد. جالب است بدانید این قضیه در سال 1940 توسط گالای دیلورث ، گالای،‌ فولکرسون و بسیاری دیگر شناخته شده بود و تنها دلیل آنها برای مطرح نکردن آن بدیهی فرض کردن این قضیه بود!</p>
</div>
<div class="section" id="id5">
<h2>ماکسیمم پادزنجیر = مینیمم افراز به زنجیر<a class="headerlink" href="#id5" title="لینک ثابت به این سر مقاله">¶</a></h2>
<p>مثل قبل می توان ابتدا به این نتیجه رسید که مینیمم افراز به زنجیر ها حداقل به اندازه ماکسیمم پادزنجیر است. (زیرا در هر زنجیر ماکسیمم یکی از راس های پادزنجیر را می توانیم استفاده کنیم). حالا می خواهیم برای اثبات تساوی یک مثال ارائه دهیم.</p>
<p>در مورد مسئله افراز راس های گراف به مینیمم تعداد مسیر در بخش 4 صحبت کردیم. کافی بود که گراف را به فرم دوبخشی در بیاوریم و ماکسیمم تطابق را پیدا کنیم. حالا می دانیم که در poset ها هر زنجیر معادل با یک مسیر است. پس مسئله مینیمم افراز به زنجیر با پیدا کردن مینیمم افراز راس ها به مسیر ها حل می شود.</p>
<div class="section" id="id6">
<h3>مسیر شبه افزایشی<a class="headerlink" href="#id6" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>پس حالا فرض کنید poset ما یک گراف جهت دار به اسم <span class="math notranslate nohighlight">\(P\)</span> باشد. گراف دوبخشی معادل آن را <span class="math notranslate nohighlight">\(G\)</span> بنامید. یک مینیمم افراز به مسیر ها در <span class="math notranslate nohighlight">\(P\)</span> را در نظر بگیرید. یال های جهت داری که در مسیر هایمان وجود دارد را مجموعه <span class="math notranslate nohighlight">\(M\)</span> بنامید. می دانیم که یال های <span class="math notranslate nohighlight">\(M\)</span> معادل با یال های یک تطابق بیشینه در <span class="math notranslate nohighlight">\(G\)</span> می باشد. شرط لازم و کافی برای بیشینه بودن یک تطابق این بود که مسیر افزایشی نداشته باشیم. بررسی می کنیم که معادل یک مسیر افزایشی در گراف جهت دارمان به چه شکل خواهد بود. یک راس آزاد در بخش اول <span class="math notranslate nohighlight">\(G\)</span> معادل است با راسی در <span class="math notranslate nohighlight">\(P\)</span> که پایان یک مسیر است. یک راس آزاد در بخش دوم <span class="math notranslate nohighlight">\(G\)</span> معادل است با راسی که در <span class="math notranslate nohighlight">\(P\)</span> شروع یک مسیر است.</p>
<p>پس می خواهیم معادل یک مسیر افزایشی که در <span class="math notranslate nohighlight">\(G\)</span> که از بخش اول شروع می شود و به بخش دوم می رود را در گراف <span class="math notranslate nohighlight">\(P\)</span> بفهمیم. <strong>مسیر شبه افزایشی</strong> در <span class="math notranslate nohighlight">\(P\)</span> را اینطور تعریف می کنیم :</p>
<p>دنباله راس های <span class="math notranslate nohighlight">\(u_1,u_2,...,u_{2k+1}\)</span> به طوریکه <span class="math notranslate nohighlight">\(u_1\)</span> ابتدای و <span class="math notranslate nohighlight">\(u_k\)</span> انتهای یک مسیر انتخاب شده در افراز مینیمم باشد. همچنین به ازای <span class="math notranslate nohighlight">\(u_{2i-1},u_{2i}\)</span> در <span class="math notranslate nohighlight">\(P\)</span> یال <span class="math notranslate nohighlight">\(u_{2i-1}u_{2i}\)</span> موجود باشد و عضو <span class="math notranslate nohighlight">\(M\)</span> نباشد و به ازای <span class="math notranslate nohighlight">\(u_{2i},u_{2i+1}\)</span> یال <span class="math notranslate nohighlight">\(u_{2i+1}u_{2i}\)</span> در <span class="math notranslate nohighlight">\(M\)</span> آمده باشد! (به عوض شدن ترتیب دقت کنید).</p>
<p>پس حالا می توان فرض کرد که راس های <span class="math notranslate nohighlight">\(P\)</span> را به کمینه تعداد مسیر ها افراز کردیم به طوریکه در <span class="math notranslate nohighlight">\(P\)</span> مسیر شبه افزایشی وجود ندارد.</p>
</div>
<div class="section" id="id7">
<h3>الگوریتم<a class="headerlink" href="#id7" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>حالا هدف ما این است که از هر کدام از زنجیر ها دقیقا یک راس را انتخاب کنیم به صورتیکه راس های انتخاب شده پادزنجیر باشند. در اینصورت می توانیم به حالت تساوی برسیم.</p>
<p>الگوریتم زیر را در نظر بگیرید :</p>
<ul class="simple">
<li>راس های اول مسیر را در نظر بگیرید. اگر بین آنها هیچ یالی نبود تنها کافیست آنها را انتخاب کنید.‌ اگر نه یعنی یالی مثل <span class="math notranslate nohighlight">\(uv\)</span> وجود دارد که <span class="math notranslate nohighlight">\(u,v\)</span> هر دو اول دو مسیر در افرازمان هستند.</li>
<li>حالا باید راس <span class="math notranslate nohighlight">\(u\)</span> را حذف کنیم. زیرا که با توجه به اینکه <span class="math notranslate nohighlight">\(u\)</span> به <span class="math notranslate nohighlight">\(v\)</span> یال دارد و <span class="math notranslate nohighlight">\(v\)</span> اول یک مسیر است پس طبق خاصیت poset می توان نتیجه گرفت <span class="math notranslate nohighlight">\(u\)</span> به تمام راس های مسیر <span class="math notranslate nohighlight">\(v\)</span> یال دارد پس اگر <span class="math notranslate nohighlight">\(u\)</span> را در پادزنجیر انتخاب کنیم هیچکدام از راس های مسیری که <span class="math notranslate nohighlight">\(v\)</span> اول آن است را نمی توانیم انتخاب کنیم پس نمی توانیم به هدفمان که انتخاب یک راس از هر مسیر است برسیم. پس <span class="math notranslate nohighlight">\(u\)</span> را حذف کنید.</li>
</ul>
<p>آنقدر این فرایند را ادامه دهید که بین راس های اول مسیر (بعد از حذف ها) هیچ یالی نباشد و یک پادزنجیر به اندازه تعداد مسیر ها بیابیم. تنها حالتی که کار ما را خراب می کند این است که یک مسیر به طور کامل حذف شود. (در این صورت پادزنجیر به اندازه تعداد مسیر های اولیه نخواهد بود).</p>
</div>
<div class="section" id="id8">
<h3>هیچ مسیری کاملا حذف نمی شود<a class="headerlink" href="#id8" title="لینک ثابت به این سر مقاله">¶</a></h3>
<p>پس ثابت می کنیم که هیچکدام از مسیر ها طی الگوریتم به طور کامل حذف نمی شوند. ایده اثبات این است که با برهان خلف فرض کنیم یک مسیر کامل حذف شده و سپس یک مسیر شبه افزایشی در گراف اولیه پیدا کنیم که با مینیمم بودن افرازمان در تناقض خواهد بود.</p>
<p>به ازای هر راس <span class="math notranslate nohighlight">\(a\)</span> به راسی مثل <span class="math notranslate nohighlight">\(b\)</span> پدر راس <span class="math notranslate nohighlight">\(a\)</span> می گوییم اگر در الگوریتم <span class="math notranslate nohighlight">\(a\)</span> به خاطر یال <span class="math notranslate nohighlight">\(ab\)</span> حذف شده باشد. یعنی در مرحله ای از الگوریتم <span class="math notranslate nohighlight">\(a,b\)</span> هر دو اول دو مسیر باشند و یال <span class="math notranslate nohighlight">\(ab\)</span> عضو <span class="math notranslate nohighlight">\(P\)</span> باشد و طبق الگوریتم بالا ما راس <span class="math notranslate nohighlight">\(a\)</span> را حذف کنیم.</p>
<p>به ازای هر راس <span class="math notranslate nohighlight">\(a\)</span> مسیری که <span class="math notranslate nohighlight">\(a\)</span> در آن است را در نظر بگیرید و راسی که در مسیر قبل از <span class="math notranslate nohighlight">\(a\)</span> است (مثل <span class="math notranslate nohighlight">\(b\)</span>) را رئیس <span class="math notranslate nohighlight">\(a\)</span> بنامید. (یعنی <span class="math notranslate nohighlight">\(ba\)</span> یالی عضو <span class="math notranslate nohighlight">\(M\)</span> باشد).</p>
<p>توجه کنید که به ازای هر راس <span class="math notranslate nohighlight">\(a\)</span> زمان حذف شدن <span class="math notranslate nohighlight">\(a\)</span> بعد از زمان حذف شدن رئیس پدر <span class="math notranslate nohighlight">\(a\)</span> است. زیرا زمانی که <span class="math notranslate nohighlight">\(a\)</span> حذف شده توسط پدرش باید اول یک مسیر باشد. این یعنی ریئس پدر (در صورت وجود) قبل از این حذف شده است.</p>
<p>حالا فرض کنید در مرحله ای راس <span class="math notranslate nohighlight">\(a\)</span> حذف شود که انتهای یک مسیر از افرازمان است. از راس <span class="math notranslate nohighlight">\(a\)</span> شروع کنید و یک مهره روی <span class="math notranslate nohighlight">\(a\)</span> بگذارید. در هر مرحله اگر مهره روی <span class="math notranslate nohighlight">\(u\)</span> باشد ابتدا مهره را به پدر <span class="math notranslate nohighlight">\(u\)</span> ببرید اگر پدر <span class="math notranslate nohighlight">\(u\)</span> اول یکی از مسیر ها باشد که مسیر شبه افزایشیمان را پیدا کردیم در غیر اینصورت مهره را به رئیس پدر <span class="math notranslate nohighlight">\(u\)</span> ببرید. به دو مورد توجه کنید :</p>
<ul class="simple">
<li>فرایند پایان پذیر است زیرا طبق آنچه گفتیم بعد از هر مرحله مهره روی راسی قرار می گیرد که زمان حذف شدن آن در الگوریتم کمتر است.</li>
<li>در هر مرحله راسی که مهره روی آن قرار دارد پدر دارد. زیرا که در الگوریتممان این راس زمانی حذف می شود (زیرا که زمان حذف شدن آن از <span class="math notranslate nohighlight">\(a\)</span> کم تر است و گفتیم <span class="math notranslate nohighlight">\(a\)</span> هم حذف می شود).</li>
</ul>
<p>پس توانستیم یک مسیر شبه افزایشی پیدا کنیم. همانطور که گفتیم تناقض حاصله نشان می دهد هیچ مسیری کاملا حذف نمی شود!</p>
</div>
</div>
</div>


			        </div>
			    </div>

                            <div class="row-fluid">
			        <div class="col-lg-12">
				    

        
            <div id="body-btn">
                
                    
                    <a href="5.html" style="float:right;" title="جریان بیشینه و تطابق" accesskey="p"><i class="fa fa-chevron-right"></i>&nbsp; قبلی</a>
                    
                    
                    <a href="7.html" style="float:left;" title="تطابق در گراف های عام" accesskey="n">بعدی &nbsp;<i class="fa fa-chevron-left"></i></a>
                    
                
            </div>
        


        <div id="body-footer">
            <div>
                <a href="https://shaazzz.ir/"><img src="/_static/shaazzz_logo.png"></a>
            </div>
            <div id="text">
                <p>
                    این کتاب توسط 
                    <a href="/contributors">
                    مشارکت کنندگان شاززز
                    </a>
                    به وجود آمده است.
                </p>
                <p>
                    این کتاب عمومی است و تحت پروانه cc-by-sa در دسترس است.
                </p>
                    <p style="font-size: 13px;">
                        آخرین به روز رسانی در آوریل 25, 2020.
                    </p>
                <p style="font-size: 13px;">
                    
                        ساخته شده به وسیله <a href="http://sphinx-doc.org/">Sphinx</a> (1.8.5) و <a href="https://github.com/saeiddrv/SphinxMinooTheme">تم مینو</a> (Beta 0.9.7).
                    
                </p>
            </div>
            <div>
                <a href="https://pdcommunity.ir/license/cc-by-sa/">
                    <img src="/_static/cc-by-sa.png">
                </a>
            </div>
        </div>
			        </div>
			    </div>
                            
                        </div>
                </div>
            </div>
            <span class="back-to-top">
                <i class="fa fa-arrow-circle-up"></i>
            </span>
        </div>
    </body>
</html>